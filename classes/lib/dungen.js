/*!
* dungen, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
*
* Generated by DuoCode Compiler 2.2.1631.0 [Community]
*/
var mscorlib = require("./mscorlib");
module.exports = (function dungen(mscorlib) {
"use strict";
var $asm = {
    fullName: "dungen",
    anonymousTypes: [],
    types: [],
    getAttrs: function() { return [new System.Reflection.AssemblyTitleAttribute.ctor("CS2JSConverter"), new System.Reflection.AssemblyDescriptionAttribute.ctor(""), new System.Reflection.AssemblyConfigurationAttribute.ctor(""), new System.Reflection.AssemblyCompanyAttribute.ctor("Bassetune Reapers"), new System.Reflection.AssemblyProductAttribute.ctor("CS2JSConverter"), new System.Reflection.AssemblyCopyrightAttribute.ctor("Copyright \xA9 Bassetune Repaers 2017"), new System.Reflection.AssemblyTrademarkAttribute.ctor(""), new System.Reflection.AssemblyCultureAttribute.ctor(""), new System.Reflection.AssemblyVersionAttribute.ctor("1.0.0.0"), new System.Reflection.AssemblyFileVersionAttribute.ctor("1.0.0.0"), new DuoCode.Runtime.CompilerAttribute.ctor("2.2.1631.0")]; }
};
var $g = (typeof(global) !== "undefined" ? global : (typeof(window) !== "undefined" ? window : self));
var CaveGeneration = $g.CaveGeneration = $g.CaveGeneration || {};
CaveGeneration.Generator = CaveGeneration.Generator || {};
var DungeonGeneration = $g.DungeonGeneration = $g.DungeonGeneration || {};
DungeonGeneration.Generator = DungeonGeneration.Generator || {};
DungeonGeneration.Generator.Domain = DungeonGeneration.Generator.Domain || {};
DungeonGeneration.Generator.Pickers = DungeonGeneration.Generator.Pickers || {};
DungeonGeneration.Generator.Plotters = DungeonGeneration.Generator.Plotters || {};
DungeonGeneration.Logging = DungeonGeneration.Logging || {};
var $d = DuoCode.Runtime;
$d.$assemblies["dungen"] = $asm;
CaveGeneration.Generator.CaveGenerator = $d.declare("CaveGeneration.Generator.CaveGenerator", 0, $asm);
var APolyShape = $g.APolyShape = $d.declare("APolyShape", 0, $asm);
var AShapeVisitor = $g.AShapeVisitor = $d.declare("AShapeVisitor", 0, $asm);
var CaveBoard = $g.CaveBoard = $d.declare("CaveBoard", 0, $asm);
var CaveCorridorFactory = $g.CaveCorridorFactory = $d.declare("CaveCorridorFactory", 0, $asm);
var CellPair = $g.CellPair = $d.declare("CellPair", 0, $asm);
var ElliShape = $g.ElliShape = $d.declare("ElliShape", 0, $asm);
var FreeShape = $g.FreeShape = $d.declare("FreeShape", 0, $asm);
var OIGrid = $g.OIGrid = $d.declare("OIGrid", 0, $asm);
var OIGridFiller = $g.OIGridFiller = $d.declare("OIGridFiller", 0, $asm);
var RectShape = $g.RectShape = $d.declare("RectShape", 0, $asm);
var ShapeCellularAutomaton = $g.ShapeCellularAutomaton = $d.declare("ShapeCellularAutomaton", 0, $asm);
var XTile = $g.XTile = $d.declare("XTile", 0, $asm);
var ZeroOneCavePlotter = $g.ZeroOneCavePlotter = $d.declare("ZeroOneCavePlotter", 0, $asm);
var ZeroOneFillerCavePlotter = $g.ZeroOneFillerCavePlotter = $d.declare("ZeroOneFillerCavePlotter", 0, 
    $asm);
var ZeroOneTwoFillerCavePlotter = $g.ZeroOneTwoFillerCavePlotter = $d.declare("ZeroOneTwoFillerCavePlotter", 
    0, $asm);
DungeonGeneration.Generator.Domain.Board = $d.declare("DungeonGeneration.Generator.Domain.Board", 0, 
    $asm);
DungeonGeneration.Generator.Domain.Cell = $d.declare("DungeonGeneration.Generator.Domain.Cell", 0, $asm);
var Corridor = $g.Corridor = $d.declare("Corridor", 0, $asm);
DungeonGeneration.Generator.Domain.Grid = $d.declare("DungeonGeneration.Generator.Domain.Grid", 0, $asm);
var Room = $g.Room = $d.declare("Room", 0, $asm);
DungeonGeneration.Generator.DungeonGenerator = $d.declare("DungeonGeneration.Generator.DungeonGenerator", 
    0, $asm);
DungeonGeneration.Generator.ForcedDungeonGenerator = $d.declare("DungeonGeneration.Generator.ForcedDungeonGenerator", 
    0, $asm);
DungeonGeneration.Generator.Pickers.CardinalPointPicker = $d.declare("DungeonGeneration.Generator.Pickers.CardinalPointPicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.CellInRangePicker = $d.declare("DungeonGeneration.Generator.Pickers.CellInRangePicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy = $d.declare("DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy", 
    0, $asm);
DungeonGeneration.Generator.Pickers.FloatInRangePicker = $d.declare("DungeonGeneration.Generator.Pickers.FloatInRangePicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.IntInRangePicker = $d.declare("DungeonGeneration.Generator.Pickers.IntInRangePicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy = $d.declare("DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy", 
    0, $asm);
DungeonGeneration.Generator.Plotters.DetailedTilesPlotter = $d.declare("DungeonGeneration.Generator.Plotters.DetailedTilesPlotter", 
    0, $asm);
DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter = $d.declare("DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter", 
    0, $asm);
DungeonGeneration.Logging.ConsoleLogger = $d.declare("DungeonGeneration.Logging.ConsoleLogger", 0, $asm);
DungeonGeneration.Logging.NullLogger = $d.declare("DungeonGeneration.Logging.NullLogger", 0, $asm);
var Forest012Plotter = $g.Forest012Plotter = $d.declare("Forest012Plotter", 0, $asm);
var Forest01Plotter = $g.Forest01Plotter = $d.declare("Forest01Plotter", 0, $asm);
var ForestGenUtil = $g.ForestGenUtil = $d.declare("ForestGenUtil", 0, $asm);
ForestGenUtil.PrepareForTestShapeVisitor = $d.declare("PrepareForTestShapeVisitor", 0, ForestGenUtil);
var CaveGenUtil = $g.CaveGenUtil = $d.declare("CaveGenUtil", 0, $asm);
CaveGenUtil.PrepareForTestShapeVisitor = $d.declare("PrepareForTestShapeVisitor", 0, CaveGenUtil);
var DunGenUtil = $g.DunGenUtil = $d.declare("DunGenUtil", 0, $asm);
$d.define(CaveGeneration.Generator.CaveGenerator, null, function($t, $p) {
    $t.$ator = function() {
        this._dunGen = null;
        this._cellularFillChance = 0;
        this._cellularSmoothingStep = 0;
        this._seed = 0;
        this._logger = null;
        this._plotter = null;
        this._mapMargin = 0;
    };
    $t.ctor = function CaveGenerator() {
        $t.$baseType.ctor.call(this);
        this._dunGen = new DungeonGeneration.Generator.ForcedDungeonGenerator.ctor(10);
        this._seed = 0;
        this._logger = new DungeonGeneration.Logging.NullLogger.ctor();
        this._cellularFillChance = 50;
        this._cellularSmoothingStep = 5;
        this.setMapMargin(1);
    };
    $p.checkConstraints = function CaveGenerator_checkConstraints() {
        if (this._mapMargin < 1)
            throw new System.FormatException.ctor$1("Invalid Map Margin: must be >= 1");
    };
    $p.setPlotter = function CaveGenerator_setPlotter(plotter) {
        this._plotter = plotter;
    };
    $p.setLogger = function CaveGenerator_setLogger(logger) {
        this._logger = logger;
        this._dunGen.setLogger(logger);
    };
    $p.setCellularFillChance = function CaveGenerator_setCellularFillChance(percentage) {
        this._cellularFillChance = percentage;
    };
    $p.setCellularSmoothingSteps = function CaveGenerator_setCellularSmoothingSteps(steps) {
        this._cellularSmoothingStep = steps;
    };
    $p.setSeed = function CaveGenerator_setSeed(seed) {
        this._seed = seed;
        this._dunGen.setSeed(seed);
    };
    $p.setCorridorWidthRange = function CaveGenerator_setCorridorWidthRange(min, max) {
        this._dunGen.setCorridorWidthRange(min, max);
    };
    $p.setCorridorLengthRange = function CaveGenerator_setCorridorLengthRange(min, max) {
        this._dunGen.setCorridorLengthRange(min, max);
    };
    $p.setRoomSizeRange = function CaveGenerator_setRoomSizeRange(min, max) {
        this._dunGen.setRoomSizeRange(min, max);
    };
    $p.setRoomsNumberRange = function CaveGenerator_setRoomsNumberRange(min, max) {
        this._dunGen.setRoomsNumberRange(min, max);
    };
    $p.setMapSize = function CaveGenerator_setMapSize(height, width) {
        this._dunGen.setMapSize(height, width);
    };
    $p.asBoard = function CaveGenerator_asBoard() {
        this.checkConstraints();

        var board = this._dunGen.asBoard();
        var roomAlgo = new ShapeCellularAutomaton.ctor(this._seed, this._cellularFillChance, this._cellularSmoothingStep);
        var shapePicker = new DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy.ctor(this._seed);

        var result = new CaveBoard.ctor$1(board.rows(), board.cols());
        var onlyRooms = new (System.Collections.Generic.List$1(IXShape, 50510).ctor)();

        this._logger.DungeonGeneration$Logging$IXLogger$info("Rooms: " + $d.toString(board.rooms().length));
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++) {
            var each = $a[$i];
            var leftVert = each.topLeftVertex();
            var rows = each.height();
            var cols = each.width();
            var currentRoom;
            if (shapePicker.drawBetween(0, 100) < 50) {
                currentRoom = new RectShape.ctor(leftVert, new OIGrid.ctor$1(rows, cols));
            }
            else {
                currentRoom = new ElliShape.ctor(leftVert, new OIGrid.ctor$1(rows, cols));
            }
            this._logger.DungeonGeneration$Logging$IXLogger$info("Shape type: " + $d.toString($d.getTypeFromInst(currentRoom)));
            roomAlgo.applyOn(currentRoom);

            this._logger.DungeonGeneration$Logging$IXLogger$info("Shape regions before clean: " + $d.toString(currentRoom.regionsNumber()));
            if (!currentRoom.hasRegions()) {
                this._logger.DungeonGeneration$Logging$IXLogger$warning("No Region found. Room will be skipped!!!");
                continue;
            }
            currentRoom.deleteRegionsButTheBiggest();
            this._logger.DungeonGeneration$Logging$IXLogger$info("Shape regions after clean: " + $d.toString(currentRoom.regionsNumber()));


            onlyRooms.Add(currentRoom);
            if (onlyRooms.get_Count() > 1) {
                var previousRoom = onlyRooms.get_Item(onlyRooms.get_Count() - 2);
                var corrIndex = onlyRooms.get_Count() - 2;
                var corr = board.corridors()[corrIndex];
                var corridorSection = corr.isVertical() ? corr.width() : corr.height();
                result.addCorridor(CaveCorridorFactory.createCorrShape(previousRoom, currentRoom, corridorSection));
            }
            result.addRoom(currentRoom);
        }
        return result;
    };
    $p.setMapCropEnabled = function CaveGenerator_setMapCropEnabled(enabled) {
        this._dunGen.setMapCropEnabled(enabled);
    };
    $p.setMapMargin = function CaveGenerator_setMapMargin(mapMargin) {
        this._mapMargin = mapMargin;
        this._dunGen.setMapMargin(mapMargin);
    };
    $p.asOIGrid = function CaveGenerator_asOIGrid() {
        return new OIGrid.ctor(this.asMatrix());
    };
    $p.asMatrix = function CaveGenerator_asMatrix() {
        this._plotter.ICaveBoardPlotter$1$applyOn(this.asBoard());
        return this._plotter.ICaveBoardPlotter$1$result();
    };
});
var IXShape = $g.IXShape = $d.type("IXShape", 66, $asm, function($t, $p) {
});
$d.define(APolyShape, null, function($t, $p) {
    $t.$intfs = [IXShape];
    $t.$ator = function() {
        this._grid = null;
        this._topLeftVertex = null;
        this._incoming = null;
        this._outcoming = null;
    };
    $t.ctor = function APolyShape(topLeftVertex, cells) {
        $t.$baseType.ctor.call(this);
        this._topLeftVertex = topLeftVertex;
        this._grid = cells;
    };
    $p.topLeftVertex = function APolyShape_topLeftVertex() {
        return this._topLeftVertex;
    };
    $p.accept = function APolyShape_accept(visitor) {
        visitor.IShapeVisitor$visit(this);
    };
    $p.grid = function APolyShape_grid() {
        return this._grid;
    };
    $p.topRightVertex = function APolyShape_topRightVertex() {
        return this._topLeftVertex.plusSize(0, this._grid.columns());
    };
    $p.forEachCell = function APolyShape_forEachCell(doFunct) {
        for (var x = 0; x < this._grid.rows(); x++) {
            for (var y = 0; y < this._grid.columns(); y++) {
                if (this.isCellValid(x, y))
                    doFunct(x, y, this);
            }
        }
    };
    $p.forEachCell2 = function APolyShape_forEachCell2(doFunct) {
        for (var x = 0; x < this._grid.rows(); x++) {
            for (var y = 0; y < this._grid.columns(); y++) {
                if (this.isCellValid(x, y))
                    doFunct(x, y, this.getCellValue(x, y));
            }
        }
    };
    $p.forEachCellAbs = function APolyShape_forEachCellAbs(doFunct) {
        for (var x = 0; x < this._grid.rows(); x++) {
            for (var y = 0; y < this._grid.columns(); y++) {
                if (this.isCellValid(x, y)) {
                    var vX = this.topLeftVertex().row();
                    var vY = this.topLeftVertex().col();
                    var absX = vX + x;
                    var absY = vY + y;
                    doFunct(absX, absY, this._grid.valueForCell(x, y));
                }
            }
        }
    };
    $p.forEachEdgeCellAbs = function APolyShape_forEachEdgeCellAbs(doFunct) {
        var edge = this.edge();
        var $iter = edge;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            var abs = each.plus(this.topLeftVertex());
            doFunct(abs.row(), abs.col(), this._grid.valueForCell(each.row(), each.col()));
        }
    };
    $p.bottomLeftVertex = function APolyShape_bottomLeftVertex() {
        return this._topLeftVertex.plusSize(this._grid.rows(), 0);
    };
    $p.bottomRightVertex = function APolyShape_bottomRightVertex() {
        return this._topLeftVertex.plusSize(this._grid.rows(), this._grid.columns());
    };
    $p.setCellValue = function APolyShape_setCellValue(cellX, cellY, v) {
        this._grid.setCellValue(cellX, cellY, v);
    };
    $p.getCellValue = function APolyShape_getCellValue(cellX, cellY) {
        return this._grid.valueForCell(cellX, cellY);
    };
    $p.hasCellValue = function APolyShape_hasCellValue(x, y, value) {
        return this._grid.hasCellValue(x, y, value);
    };
    $p.shortestCellPair = function APolyShape_shortestCellPair(aShape) {
        var myEdge = this.edge();
        var yourEdge = aShape.IXShape$edge();

        var shortestPath = 0;
        var cell1Sel = null;
        var cell2Sel = null;
        var firstTime = true;
        var $iter = myEdge;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var myCell = $enumerator.System$Collections$IEnumerator$get_Current();
            var myCellAbs = myCell.plus(this.topLeftVertex());
            var $iter1 = yourEdge;
            var $enumerator1 = $iter1.System$Collections$IEnumerable$GetEnumerator();
            while ($enumerator1.System$Collections$IEnumerator$MoveNext()) {
                var yourCell = $enumerator1.System$Collections$IEnumerator$get_Current();
                var yourCellAbs = yourCell.plus(aShape.IXShape$topLeftVertex());
                var magn = myCellAbs.magnetude(yourCellAbs);
                if (firstTime) {
                    shortestPath = magn;
                    firstTime = false;
                    cell1Sel = myCellAbs;
                    cell2Sel = yourCellAbs;
                }
                else if (magn < shortestPath) {
                    shortestPath = magn;
                    cell1Sel = myCellAbs;
                    cell2Sel = yourCellAbs;
                }
            }
        }

        if (firstTime)
            return null;
        return new CellPair.ctor(cell1Sel, cell2Sel);
    };
    $p.edge = function APolyShape_edge() {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        this.forEachCell($d.delegate(function(x, y, shape) {
            if (shape.IXShape$hasCellValue(x, y, XTile().FLOOR)) {
                for (var neighbourX = x - 1; neighbourX <= x + 1; neighbourX++) {
                    for (var neighbourY = y - 1; neighbourY <= y + 1; neighbourY++) {
                        if (shape.IXShape$isCellValid(neighbourX, neighbourY)) {
                            if (neighbourX != x || neighbourY != y) {
                                if (shape.IXShape$hasCellValue(neighbourX, neighbourY, XTile().WALL)) {
                                    var cell = new DungeonGeneration.Generator.Domain.Cell.ctor(x, y);
                                    if (!result.Contains(cell))
                                        result.Add(cell);
                                }
                            }
                        }
                        else {
                            var cell = new DungeonGeneration.Generator.Domain.Cell.ctor(x, y);
                            if (!result.Contains(cell))
                                result.Add(cell);
                        }
                    }
                }
            }
        }, this));
        return result;
    };
    $p.regionsNumber = function APolyShape_regionsNumber() {
        return this.regionsWithValue(XTile().FLOOR).get_Count();
    };
    $p.regionsWithValue = function APolyShape_regionsWithValue(value) {
        var regions = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885), 26117).ctor)();
        var rows = this.grid().rows();
        var columns = this.grid().columns();

        var mapFlags = $d.array(System.Int32, rows * columns, [rows, columns]);

        for (var x = 0; x < rows; x++) {
            for (var y = 0; y < columns; y++) {
                if (mapFlags[x * mapFlags.$ranks[1] + y] == 0 && this.hasCellValue(x, y, value)) {
                    var newRegion = this.regionFrom(x, y);
                    regions.Add(newRegion);
                    var $iter = newRegion;
                    var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
                    while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
                        var tile = $enumerator.System$Collections$IEnumerator$get_Current();
                        mapFlags[tile.row() * mapFlags.$ranks[1] + tile.col()] = 1;
                    }
                }
            }
        }
        return regions;
    };
    $p.deleteRegionsButTheBiggest = function APolyShape_deleteRegionsButTheBiggest() {
        var regions = this.regionsWithValue(XTile().FLOOR);
        if (regions.get_Count() == 0)
            return;
        if (regions.get_Count() == 1)
            return;
        var biggest = null;
        var toDelete = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        var $iter = regions;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if (biggest == null) {
                biggest = each;
            }
            else if (each.get_Count() > biggest.get_Count()) {
                toDelete.AddRange(biggest);
                biggest = each;
            }
            else {
                toDelete.AddRange(each);
            }
        }
        var $iter1 = toDelete;
        var $enumerator1 = $iter1.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator1.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator1.System$Collections$IEnumerator$get_Current();
            this.setCellValue(each.row(), each.col(), XTile().WALL);
        }
    };
    $p.hasRegions = function APolyShape_hasRegions() {
        return this.regionsNumber() > 0;
    };
    $p.regionFrom = function APolyShape_regionFrom(startX, startY) {
        var tiles = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 14885).ctor)();
        var rows = this.grid().rows();
        var columns = this.grid().columns();

        var mapFlags = $d.array(System.Int32, rows * columns, [rows, columns]);
        var tileType = this.getCellValue(startX, startY);

        var queue = new (System.Collections.Generic.Queue$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        queue.Enqueue(new DungeonGeneration.Generator.Domain.Cell.ctor(startX, startY));
        mapFlags[startX * mapFlags.$ranks[1] + startY] = 1;

        while (queue.get_Count() > 0) {
            var tile = queue.Dequeue();
            tiles.Add(tile);

            for (var x = tile.row() - 1; x <= tile.row() + 1; x++) {
                for (var y = tile.col() - 1; y <= tile.col() + 1; y++) {
                    if (this.isCellValid(x, y) && (y == tile.col() || x == tile.row())) {
                        if (mapFlags[x * mapFlags.$ranks[1] + y] == 0 && this.hasCellValue(x, y, tileType)) {
                            mapFlags[x * mapFlags.$ranks[1] + y] = 1;
                            queue.Enqueue(new DungeonGeneration.Generator.Domain.Cell.ctor(x, y));
                        }
                    }
                }
            }
        }
        return tiles;
    };
    $p.isWithin = function APolyShape_isWithin(container) {
        return this.grid().isWithin(container, this.topLeftVertex());
    };
    $p.collidesWith = function APolyShape_collidesWith(other) {
        var cells = this._topLeftVertex.cells(this.bottomRightVertex());
        for (var $i = 0, $length = cells.length; $i < $length; $i++) {
            var each = cells[$i];
            if (other.IXShape$containsCell(each))
                return true;
        }
        return false;
    };
    $p.containsCell = function APolyShape_containsCell(aCell) {
        return aCell.isWithin$1(this.topLeftVertex(), this.bottomRightVertex());
    };
    $p.walkableCells = function APolyShape_walkableCells() {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        this.forEachCellAbs($d.delegate(function(row, col, value) {
            if (value == XTile().FLOOR)
                result.Add(new DungeonGeneration.Generator.Domain.Cell.ctor(row, col));
        }, this));
        return result.ToArray();
    };
    $p.setIncoming = function APolyShape_setIncoming(incoming) {
        this._incoming = incoming;
    };
    $p.setOutcoming = function APolyShape_setOutcoming(outcoming) {
        this._outcoming = outcoming;
    };
    $p.hasCellAbsValue = function APolyShape_hasCellAbsValue(absCell, value) {
        var relCell = absCell.minusCell(this.topLeftVertex().row(), this.topLeftVertex().col());
        return this.hasCellValue(relCell.row(), relCell.col(), value);
    };
    $p.absCellsFacingOutcoming = function APolyShape_absCellsFacingOutcoming() {
        if (this._outcoming == null)
            return $d.array(DungeonGeneration.Generator.Domain.Cell, 0);
        return this.absCellsFacingShape(this._outcoming);
    };
    $p.absCellsFacingShape = function APolyShape_absCellsFacingShape(aShape) {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        this.forEachEdgeCellAbs($d.delegate(function(row, col, value) {
            var cell = new DungeonGeneration.Generator.Domain.Cell.ctor(row, col);
            if (aShape.IXShape$hasAbsCellFacing(cell))
                result.Add(cell);
        }, this));
        return result.ToArray();
    };
    $p.absCellsFacingIncoming = function APolyShape_absCellsFacingIncoming() {
        if (this._incoming == null)
            return $d.array(DungeonGeneration.Generator.Domain.Cell, 0);
        return this.absCellsFacingShape(this._incoming);
    };
    $p.absCellFacing = function APolyShape_absCellFacing(aCell) {
        var cellsOnEdge = this.edge();

        if (cellsOnEdge.Contains(aCell.plusCell(1, 0))) {
            return aCell.plusCell(1, 0);
        }
        if (cellsOnEdge.Contains(aCell.plusCell(0, 1))) {
            return aCell.plusCell(0, 1);
        }
        if (cellsOnEdge.Contains(aCell.minusCell(1, 0))) {
            return aCell.minusCell(1, 0);
        }
        if (cellsOnEdge.Contains(aCell.minusCell(0, 1))) {
            return aCell.minusCell(0, 1);
        }
        return null;
    };
    $p.hasAbsCellFacing = function APolyShape_hasAbsCellFacing(cell) {
        return this.absCellFacing(cell) != null;
    };
    $p.height = function APolyShape_height() {
        return this.grid().rows();
    };
    $p.width = function APolyShape_width() {
        return this.grid().columns();
    };
    $p.getIncoming = function APolyShape_getIncoming() {
        return this._incoming;
    };
    $p.getOutcoming = function APolyShape_getOutcoming() {
        return this._outcoming;
    };
    $p.IXShape$topLeftVertex = $p.topLeftVertex;
    $p.IXShape$topRightVertex = $p.topRightVertex;
    $p.IXShape$bottomLeftVertex = $p.bottomLeftVertex;
    $p.IXShape$bottomRightVertex = $p.bottomRightVertex;
    $p.IXShape$grid = $p.grid;
    $p.IXShape$setCellValue = $p.setCellValue;
    $p.IXShape$forEachCell = $p.forEachCell;
    $p.IXShape$forEachCell2 = $p.forEachCell2;
    $p.IXShape$forEachCellAbs = $p.forEachCellAbs;
    $p.IXShape$hasCellValue = $p.hasCellValue;
    $p.IXShape$hasCellAbsValue = $p.hasCellAbsValue;
    $p.IXShape$isWithin = $p.isWithin;
    $p.IXShape$accept = $p.accept;
    $p.IXShape$edge = $p.edge;
    $p.IXShape$shortestCellPair = $p.shortestCellPair;
    $p.IXShape$collidesWith = $p.collidesWith;
    $p.IXShape$containsCell = $p.containsCell;
    $p.IXShape$forEachEdgeCellAbs = $p.forEachEdgeCellAbs;
    $p.IXShape$setIncoming = $p.setIncoming;
    $p.IXShape$setOutcoming = $p.setOutcoming;
    $p.IXShape$getIncoming = $p.getIncoming;
    $p.IXShape$getOutcoming = $p.getOutcoming;
    $p.IXShape$walkableCells = $p.walkableCells;
    $p.IXShape$absCellFacing = $p.absCellFacing;
    $p.IXShape$hasAbsCellFacing = $p.hasAbsCellFacing;
});
var IShapeVisitor = $g.IShapeVisitor = $d.type("IShapeVisitor", 66, $asm, function($t, $p) {
});
$d.define(AShapeVisitor, null, function($t, $p) {
    $t.$intfs = [IShapeVisitor];
    $t.ctor = function AShapeVisitor() {
        $t.$baseType.ctor.call(this);
    };
    $p.visit$4 = function AShapeVisitor_visit(aShape) {
        this._visit$4($d.as(aShape, RectShape));
        this._visit($d.as(aShape, APolyShape));
        this._visit$3($d.as(aShape, IXShape));
    };
    $p.visit = function AShapeVisitor_visit(aShape) {
        if ($d.is(aShape, RectShape))
            this.visit$4($d.as(aShape, RectShape));
        else if ($d.is(aShape, ElliShape))
            this.visit$1($d.as(aShape, ElliShape));
        else
            throw new System.NotImplementedException.ctor$1("Missing case for: " + $d.toString($d.getTypeFromInst(aShape)));
    };
    $p.visit$3 = function AShapeVisitor_visit(aShape) {
        if ($d.is(aShape, APolyShape))
            this.visit($d.as(aShape, APolyShape));
        else if ($d.is(aShape, FreeShape))
            this.visit$2($d.as(aShape, FreeShape));
        else
            throw new System.NotImplementedException.ctor$1("Missing case for: " + $d.toString($d.getTypeFromInst(aShape)));
    };
    $p.visit$1 = function AShapeVisitor_visit(aShape) {
        this._visit$1($d.as(aShape, ElliShape));
        this._visit($d.as(aShape, APolyShape));
        this._visit$3($d.as(aShape, IXShape));
    };
    $p.visit$2 = function AShapeVisitor_visit(aShape) {
        this._visit$2($d.as(aShape, FreeShape));
        this._visit$3($d.as(aShape, IXShape));
    };
    $p._visit$3 = function AShapeVisitor__visit(aShape) {
    };
    $p._visit = function AShapeVisitor__visit(aShape) {
    };
    $p._visit$4 = function AShapeVisitor__visit(aShape) {
    };
    $p._visit$1 = function AShapeVisitor__visit(aShape) {
    };
    $p._visit$2 = function AShapeVisitor__visit(aShape) {
    };
    $p.IShapeVisitor$visit$3 = $p.visit$3;
    $p.IShapeVisitor$visit = $p.visit;
    $p.IShapeVisitor$visit$4 = $p.visit$4;
    $p.IShapeVisitor$visit$1 = $p.visit$1;
    $p.IShapeVisitor$visit$2 = $p.visit$2;
});
$d.define(CaveBoard, null, function($t, $p) {
    $t.$ator = function() {
        this._grid = null;
        this._rooms = null;
        this._corrs = null;
        this._roomsAndCorrs = null;
    };
    $t.ctor$1 = function CaveBoard(rows, columns) {
        $t.ctor.call(this, new OIGrid.ctor$1(rows, columns));
    };
    $t.ctor = function CaveBoard(mapGrid) {
        $t.$baseType.ctor.call(this);
        this._grid = mapGrid;
        this._rooms = new (System.Collections.Generic.List$1(IXShape, 50510).ctor)();
        this._corrs = new (System.Collections.Generic.List$1(IXShape, 50510).ctor)();
        this._roomsAndCorrs = new (System.Collections.Generic.List$1(IXShape, 50510).ctor)();
    };
    $p.addRoom = function CaveBoard_addRoom(aRoom) {
        if (this._roomsAndCorrs.get_Count() != 0) {
            var prevCorr = this._roomsAndCorrs.get_Item(this._roomsAndCorrs.get_Count() - 1);
            prevCorr.IXShape$setOutcoming(aRoom);
            aRoom.IXShape$setIncoming(prevCorr);
        }
        this._rooms.Add(aRoom);
        this._roomsAndCorrs.Add(aRoom);
    };
    $p.addCorridor = function CaveBoard_addCorridor(corr) {
        if (this._roomsAndCorrs.get_Count() != 0) {
            var prevRoom = this._roomsAndCorrs.get_Item(this._roomsAndCorrs.get_Count() - 1);
            prevRoom.IXShape$setOutcoming(corr);
            corr.IXShape$setIncoming(prevRoom);
        }
        this._corrs.Add(corr);
        this._roomsAndCorrs.Add(corr);
    };
    $p.numberOfRoomsAndCorridors = function CaveBoard_numberOfRoomsAndCorridors() {
        return this._roomsAndCorrs.get_Count();
    };
    $p.asTilesMatrix = function CaveBoard_asTilesMatrix(plotter) {
        var result = this._grid.toIntMatrix();

        if (this._roomsAndCorrs.get_Count() > 0) {
            throw new System.NotImplementedException.ctor();
        }
        return result;
    };
    $p.all = function CaveBoard_all() {
        return this._roomsAndCorrs.ToArray();
    };
    $p.rooms = function CaveBoard_rooms() {
        return this._rooms.ToArray();
    };
    $p.corridors = function CaveBoard_corridors() {
        return this._corrs.ToArray();
    };
    $p.rows = function CaveBoard_rows() {
        return this._grid.rows();
    };
    $p.cols = function CaveBoard_cols() {
        return this._grid.columns();
    };
    $p.isEmpty = function CaveBoard_isEmpty() {
        return this.numberOfRoomsAndCorridors() == 0;
    };
    $p.accept = function CaveBoard_accept(visitor) {
        var $iter = this._roomsAndCorrs;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            each.IXShape$accept(visitor);
        }
    };
});
$d.define(CaveCorridorFactory, null, function($t, $p) {
    $t.ctor = function CaveCorridorFactory() {
        $t.$baseType.ctor.call(this);
    };
    $t.createCorrShape = function CaveCorridorFactory_createCorrShape(roomA, roomB, corrWidth) {
        var pair = roomA.IXShape$shortestCellPair(roomB);
        var line = $t.GetLine(pair.cell1, pair.cell2);
        var corrAtoB = new FreeShape.ctor();
        var $iter = line;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            var vCells = $t.DrawCircle(each, corrWidth);
            var $iter1 = vCells;
            var $enumerator1 = $iter1.System$Collections$IEnumerable$GetEnumerator();
            while ($enumerator1.System$Collections$IEnumerator$MoveNext()) {
                var vEach = $enumerator1.System$Collections$IEnumerator$get_Current();
                if (!roomA.IXShape$hasCellAbsValue(vEach, XTile().FLOOR) && !roomB.IXShape$hasCellAbsValue(vEach, 
                    XTile().FLOOR)) {
                    corrAtoB.add(vEach);
                }
            }
        }
        return corrAtoB;
    };
    $t.GetLine = function CaveCorridorFactory_GetLine(from, to) {
        var line = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 14885).ctor)();

        var x = from.row();
        var y = from.col();

        var dx = to.row() - from.row();
        var dy = to.col() - from.col();

        var inverted = false;
        var step = System.Math.Sign(dx);
        var gradientStep = System.Math.Sign(dy);

        var longest = System.Math.Abs(dx);
        var shortest = System.Math.Abs(dy);

        if (longest < shortest) {
            inverted = true;
            longest = System.Math.Abs(dy);
            shortest = System.Math.Abs(dx);

            step = System.Math.Sign(dy);
            gradientStep = System.Math.Sign(dx);
        }

        var gradientAccumulation = (longest / 2 | 0);
        for (var i = 0; i < longest; i++) {
            line.Add(new DungeonGeneration.Generator.Domain.Cell.ctor(x, y));

            if (inverted) {
                y += step;
            }
            else {
                x += step;
            }

            gradientAccumulation += shortest;
            if (gradientAccumulation >= longest) {
                if (inverted) {
                    x += gradientStep;
                }
                else {
                    y += gradientStep;
                }
                gradientAccumulation -= longest;
            }
        }
        return line;
    };
    $t.DrawCircle = function CaveCorridorFactory_DrawCircle(cell, sectionSize) {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        for (var row = -sectionSize; row <= sectionSize; row++) {
            for (var col = -sectionSize; col <= sectionSize; col++) {
                if (row * row + col * col <= sectionSize * sectionSize) {
                    var drawX = cell.row() + row;
                    var drawY = cell.col() + col;

                    result.Add(new DungeonGeneration.Generator.Domain.Cell.ctor(drawX, drawY));
                }
            }
        }
        return result;
    };
});
$d.define(CellPair, null, function($t, $p) {
    $t.$ator = function() {
        this.cell1 = null;
        this.cell2 = null;
    };
    $t.ctor = function CellPair(cell1Sel, cell2Sel) {
        $t.$baseType.ctor.call(this);
        this.cell1 = cell1Sel;
        this.cell2 = cell2Sel;
    };
    $p.ToString = function CellPair_ToString() {
        return "Pair: " + $d.toString(this.cell1) + " " + $d.toString(this.cell2);
    };
});
$d.define(ElliShape, APolyShape, function($t, $p) {
    $t.$intfs = [IXShape];
    $t.ctor = function ElliShape(topLeftVertex, map) {
        $t.$baseType.ctor.call(this, topLeftVertex, map);
    };
    $p.isCellValid = function ElliShape_isCellValid(row, col) {
        if (row < 0 || row >= this.grid().rows() || col < 0 || col >= this.grid().columns())
            return false;



        var center_row = this.grid().rows() / 2;
        var center_col = this.grid().columns() / 2;
        var radius_horiz = center_col;
        var radius_vert = center_row;

        var sqrY = System.Math.Pow((row - center_row), 2);
        var sqrX = System.Math.Pow((col - center_col), 2);
        var sqrRadHor = System.Math.Pow(radius_horiz, 2);
        var sqrRadVer = System.Math.Pow(radius_vert, 2);

        var result = (sqrX / sqrRadHor + sqrY / sqrRadVer);
        return result <= 1;
    };
    $p.IXShape$isCellValid = $p.isCellValid;
});
$d.define(FreeShape, null, function($t, $p) {
    $t.$intfs = [IXShape];
    $t.$ator = function() {
        this._cells = null;
        this._incoming = null;
        this._outcoming = null;
    };
    $t.ctor = function FreeShape() {
        $t.$baseType.ctor.call(this);
        this._cells = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
    };
    $p.add$1 = function FreeShape_add(vCells) {
        var $iter = vCells;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            this.add(each);
        }
    };
    $p.add = function FreeShape_add(each) {
        if (this._cells.Contains(each))
            return;
        this._cells.Add(each);
    };
    $p.accept = function FreeShape_accept(visitor) {
        visitor.IShapeVisitor$visit$2(this);
    };
    $p.bottomLeftVertex = function FreeShape_bottomLeftVertex() {
        throw new System.NotImplementedException.ctor();
    };
    $p.edge = function FreeShape_edge() {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        this.forEachCell($d.delegate(function(x, y, shape) {
            if (shape.IXShape$hasCellValue(x, y, XTile().FLOOR)) {
                for (var neighbourX = x - 1; neighbourX <= x + 1; neighbourX++) {
                    for (var neighbourY = y - 1; neighbourY <= y + 1; neighbourY++) {
                        if (shape.IXShape$isCellValid(neighbourX, neighbourY)) {
                            if (neighbourX != x || neighbourY != y) {
                                if (shape.IXShape$hasCellValue(neighbourX, neighbourY, XTile().WALL)) {
                                    var cell = new DungeonGeneration.Generator.Domain.Cell.ctor(x, y);
                                    if (!result.Contains(cell))
                                        result.Add(cell);
                                }
                            }
                        }
                        else {
                            var cell = new DungeonGeneration.Generator.Domain.Cell.ctor(x, y);
                            if (!result.Contains(cell))
                                result.Add(cell);
                        }
                    }
                }
            }
        }, this));
        return result;
    };
    $p.forEachCell = function FreeShape_forEachCell(doFunct) {
        var $iter = this._cells;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            doFunct(each.row(), each.col(), this);
        }
    };
    $p.forEachCellAbs = function FreeShape_forEachCellAbs(doFunct) {
        var $iter = this._cells;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            doFunct(each.row(), each.col(), XTile().FLOOR);
        }
    };
    $p.hasCellValue = function FreeShape_hasCellValue(row, col, v) {
        if (!this.isCellValid(row, col))
            return false;
        if (v == XTile().FLOOR)
            return true;
        else
            return false;
    };
    $p.isCellValid = function FreeShape_isCellValid(row, col) {
        var $iter = this._cells;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if (each.row() == row && each.col() == col)
                return true;
        }
        return false;
    };
    $p.grid = function FreeShape_grid() {
        throw new System.NotImplementedException.ctor();
    };
    $p.setCellValue = function FreeShape_setCellValue(cellX, cellY, v) {
        this._cells.Add(new DungeonGeneration.Generator.Domain.Cell.ctor(cellX, cellY));
    };
    $p.shortestCellPair = function FreeShape_shortestCellPair(other) {
        throw new System.NotImplementedException.ctor();
    };
    $p.topLeftVertex = function FreeShape_topLeftVertex() {
        throw new System.NotImplementedException.ctor();
    };
    $p.topRightVertex = function FreeShape_topRightVertex() {
        throw new System.NotImplementedException.ctor();
    };
    $p.isWithin = function FreeShape_isWithin(grid) {
        throw new System.NotImplementedException.ctor();
    };
    $p.collidesWith = function FreeShape_collidesWith(each) {
        throw new System.NotImplementedException.ctor();
    };
    $p.containsCell = function FreeShape_containsCell(each) {
        throw new System.NotImplementedException.ctor();
    };
    $p.forEachEdgeCellAbs = function FreeShape_forEachEdgeCellAbs(doFunct) {
        var edge = this.edge();
        var $iter = edge;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            doFunct(each.row(), each.col(), XTile().FLOOR);
        }
    };
    $p.walkableCells = function FreeShape_walkableCells() {
        return this._cells.ToArray();
    };
    $p.setIncoming = function FreeShape_setIncoming(incoming) {
        this._incoming = incoming;
    };
    $p.setOutcoming = function FreeShape_setOutcoming(outcoming) {
        this._outcoming = outcoming;
    };
    $p.bottomRightVertex = function FreeShape_bottomRightVertex() {
        throw new System.NotImplementedException.ctor();
    };
    $p.hasCellAbsValue = function FreeShape_hasCellAbsValue(absCell, v) {
        return this.hasCellValue(absCell.row(), absCell.col(), v);
    };
    $p.absCellFacing = function FreeShape_absCellFacing(aCell) {
        var cellsOnEdge = this.edge();

        if (cellsOnEdge.Contains(aCell.plusCell(1, 0))) {
            return aCell.plusCell(1, 0);
        }
        if (cellsOnEdge.Contains(aCell.plusCell(0, 1))) {
            return aCell.plusCell(0, 1);
        }
        if (cellsOnEdge.Contains(aCell.minusCell(1, 0))) {
            return aCell.minusCell(1, 0);
        }
        if (cellsOnEdge.Contains(aCell.minusCell(0, 1))) {
            return aCell.minusCell(0, 1);
        }
        return null;
    };
    $p.hasAbsCellFacing = function FreeShape_hasAbsCellFacing(cell) {
        return this.absCellFacing(cell) != null;
    };
    $p.getIncoming = function FreeShape_getIncoming() {
        return this._incoming;
    };
    $p.getOutcoming = function FreeShape_getOutcoming() {
        return this._outcoming;
    };
    $p.forEachCell2 = function FreeShape_forEachCell2(doFunct) {
        var $iter = this._cells;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            doFunct(each.row(), each.col(), XTile().FLOOR);
        }
    };
    $p.IXShape$topLeftVertex = $p.topLeftVertex;
    $p.IXShape$topRightVertex = $p.topRightVertex;
    $p.IXShape$bottomLeftVertex = $p.bottomLeftVertex;
    $p.IXShape$bottomRightVertex = $p.bottomRightVertex;
    $p.IXShape$grid = $p.grid;
    $p.IXShape$setCellValue = $p.setCellValue;
    $p.IXShape$forEachCell = $p.forEachCell;
    $p.IXShape$forEachCell2 = $p.forEachCell2;
    $p.IXShape$forEachCellAbs = $p.forEachCellAbs;
    $p.IXShape$isCellValid = $p.isCellValid;
    $p.IXShape$hasCellValue = $p.hasCellValue;
    $p.IXShape$hasCellAbsValue = $p.hasCellAbsValue;
    $p.IXShape$isWithin = $p.isWithin;
    $p.IXShape$accept = $p.accept;
    $p.IXShape$edge = $p.edge;
    $p.IXShape$shortestCellPair = $p.shortestCellPair;
    $p.IXShape$collidesWith = $p.collidesWith;
    $p.IXShape$containsCell = $p.containsCell;
    $p.IXShape$forEachEdgeCellAbs = $p.forEachEdgeCellAbs;
    $p.IXShape$setIncoming = $p.setIncoming;
    $p.IXShape$setOutcoming = $p.setOutcoming;
    $p.IXShape$getIncoming = $p.getIncoming;
    $p.IXShape$getOutcoming = $p.getOutcoming;
    $p.IXShape$walkableCells = $p.walkableCells;
    $p.IXShape$absCellFacing = $p.absCellFacing;
    $p.IXShape$hasAbsCellFacing = $p.hasAbsCellFacing;
});
$d.define(DungeonGeneration.Generator.Domain.Grid, null, function($t, $p) {
    $t.$ator = function() {
        this._columns = 0;
        this._rows = 0;
    };
    $t.ctor = function Grid(rows, columns) {
        $t.$baseType.ctor.call(this);
        this._rows = rows;
        this._columns = columns;
    };
    $p.columns = function Grid_columns() {
        return this._columns;
    };
    $p.rows = function Grid_rows() {
        return this._rows;
    };
    $p.isWithin = function Grid_isWithin(container, topLeftVertex) {
        if (!this.absTopLeftVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absTopRightVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absBotRightVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absBotLeftVertexUsing(topLeftVertex).isWithin(container))
            return false;
        return true;
    };
    $p.absTopLeftVertexUsing = function Grid_absTopLeftVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(0, 0);
    };
    $p.absBotLeftVertexUsing = function Grid_absBotLeftVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(this._rows - 1, 0);
    };
    $p.absBotRightVertexUsing = function Grid_absBotRightVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(this._rows - 1, this._columns - 1);
    };
    $p.absTopRightVertexUsing = function Grid_absTopRightVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(0, this._columns - 1);
    };
    $p.hasCell = function Grid_hasCell(rowIndex, colIndex) {
        if (rowIndex < 0 || rowIndex >= this._rows)
            return false;
        if (colIndex < 0 || colIndex >= this._columns)
            return false;
        return true;
    };
    $p.topLeftVertex = function Grid_topLeftVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0);
    };
    $p.topRightVertex = function Grid_topRightVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(0, this._columns - 1);
    };
    $p.bottomLeftVertex = function Grid_bottomLeftVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._rows - 1, 0);
    };
    $p.bottomRightVertex = function Grid_bottomRightVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._rows - 1, this._columns - 1);
    };
    $p.ToString = function Grid_ToString() {
        return "XGrid: [" + $d.toString(this._rows) + ", " + $d.toString(this._columns) + "]";
    };
});
$d.define(OIGrid, DungeonGeneration.Generator.Domain.Grid, function($t, $p) {
    $t.$ator = function() {
        this._cells = null;
    };
    $p.toIntMatrix = function OIGrid_toIntMatrix() {
        return $d.cast(this._cells.Clone(), $d.arrayType(System.Int32, 2));
    };
    $p.mirrorOnColumns = function OIGrid_mirrorOnColumns() {
        var result = new OIGrid.ctor$1(this.rows(), this.columns());
        for (var x = 0; x < this.rows(); x++) {
            for (var y = 0; y < this.columns(); y++) {
                var invertedY = this.columns() - 1 - y;
                result.set_Item(x, invertedY, this._cells[x * this._cells.$ranks[1] + y]);
            }
        }
        return result;
    };
    $p.replace = function OIGrid_replace(toBeReplace, newValue) {
        var result = new OIGrid.ctor$1(this.rows(), this.columns());
        this.forEach2($d.delegate(function(row, col, value) {
            if (value == toBeReplace)
                result.setCellValue(row, col, newValue);
            else
                result.setCellValue(row, col, value);
        }, this));
        return result;
    };
    $p.mirrorOnRows = function OIGrid_mirrorOnRows() {
        var result = new OIGrid.ctor$1(this.rows(), this.columns());
        for (var x = 0; x < this.rows(); x++) {
            for (var y = 0; y < this.columns(); y++) {
                var inverted = this.rows() - 1 - x;
                result.set_Item(inverted, y, this._cells[x * this._cells.$ranks[1] + y]);
            }
        }
        return result;
    };
    $p.rotate90 = function OIGrid_rotate90() {
        var result = new OIGrid.ctor$1(this.columns(), this.rows());
        for (var row = 0; row < result.rows(); row++) {
            for (var col = 0; col < result.columns(); col++) {
                var cRow = this.rows() - 1 - col;
                var cCol = row;
                result.set_Item(row, col, this._cells[cRow * this._cells.$ranks[1] + cCol]);
            }
        }
        return result;
    };
    $p.existsCellNeighborValue = function OIGrid_existsCellNeighborValue(row, col, value) {
        if (this.isCellValid(row - 1, col) && this.hasCellValue(row - 1, col, value)) {
            return true;
        }
        if (this.isCellValid(row + 1, col) && this.hasCellValue(row + 1, col, value)) {
            return true;
        }
        if (this.isCellValid(row, col - 1) && this.hasCellValue(row, col - 1, value)) {
            return true;
        }
        if (this.isCellValid(row, col + 1) && this.hasCellValue(row, col + 1, value)) {
            return true;
        }
        return false;
    };
    $p.clone = function OIGrid_clone() {
        var result = new OIGrid.ctor$1(this.rows(), this.columns());
        this.forEach2($d.delegate(function(x, y, value) {
            result.set_Item(x, y, value);
        }, this));
        return result;
    };
    $p.invert = function OIGrid_invert() {
        var result = new OIGrid.ctor$1(this.rows(), this.columns());
        this.forEach2($d.delegate(function(x, y, value) {
            var valueInverted = value == 0 ? 1 : 0;
            result.set_Item(x, y, valueInverted);
        }, this));
        return result;
    };
    $t.ctor$1 = function OIGrid(rows, columns) {
        $t.ctor.call(this, $d.array(System.Int32, rows * columns, [rows, columns]));
    };
    $t.ctor = function OIGrid(cells) {
        $t.$baseType.ctor.call(this, cells.GetLength(0), cells.GetLength(1));
        this._cells = cells;
    };
    $p.get_Item = function OIGrid_get_Item(x, y) {
        return this._cells[x * this._cells.$ranks[1] + y];
    };
    $p.set_Item = function OIGrid_set_Item(x, y, value) {
        this._cells[x * this._cells.$ranks[1] + y] = value;
    };
    $p.valueForCell = function OIGrid_valueForCell(x, y) {
        if (x < 0 || x >= this.rows())
            return -2147483648;
        if (y < 0 || y >= this.columns())
            return -2147483648;
        return this._cells[x * this._cells.$ranks[1] + y];
    };
    $p.Equals = function OIGrid_Equals(obj) {
        var other = $d.as(obj, OIGrid);
        if (this.rows() != other.rows())
            return false;
        if (this.columns() != other.columns())
            return false;
        var allEquals = true;
        this.forEach($d.delegate(function(x, y, map) {
            if (!other.hasCellValue(x, y, this._cells[x * this._cells.$ranks[1] + y])) {
                allEquals = false;
                return;
            }
        }, this));
        return allEquals;
    };
    $p.forEach = function OIGrid_forEach(doFunct) {
        for (var x = 0; x < this.rows(); x++) {
            for (var y = 0; y < this.columns(); y++) {
                doFunct(x, y, this);
            }
        }
    };
    $p.forEach2 = function OIGrid_forEach2(doFunct) {
        for (var x = 0; x < this.rows(); x++) {
            for (var y = 0; y < this.columns(); y++) {
                doFunct(x, y, this._cells[x * this._cells.$ranks[1] + y]);
            }
        }
    };
    $p.isCellOnEdge = function OIGrid_isCellOnEdge(cellX, cellY) {
        return cellX == 0 || cellX == this.rows() - 1 || cellY == 0 || cellY == this.columns() - 1;
    };
    $p.isCellValid = function OIGrid_isCellValid(cellX, cellY) {
        return cellX >= 0 && cellX <= this.rows() - 1 && cellY >= 0 && cellY <= this.columns() - 1;
    };
    $p.printOnConsole = function OIGrid_printOnConsole() {
        System.Console.WriteLine$10("Size: [" + $d.toString(this.rows()) + ", " + $d.toString(this.columns()) + "]");
        var row = "";
        for (var eachRow = 0; eachRow < this.rows(); eachRow++) {
            row = "";
            for (var eachCol = 0; eachCol < this.columns(); eachCol++) {
                row += $d.toString(this._cells[eachRow * this._cells.$ranks[1] + eachCol]);
            }
            System.Console.WriteLine$10(row);
        }
    };
    $p.asMatrix = function OIGrid_asMatrix() {
        return this._cells;
    };
    $p.setCellValue = function OIGrid_setCellValue(cellX, cellY, value) {
        if (!this.isCellValid(cellX, cellY))
            return;
        this._cells[cellX * this._cells.$ranks[1] + cellY] = value;
    };
    $p.hasCellValue = function OIGrid_hasCellValue(cellX, cellY, value) {
        if (!this.isCellValid(cellX, cellY))
            return false;
        return this._cells[cellX * this._cells.$ranks[1] + cellY] == value;
    };
});
$d.define(OIGridFiller, AShapeVisitor, function($t, $p) {
    $t.$intfs = [IShapeVisitor];
    $t.$ator = function() {
        this.grid = null;
    };
    $t.ctor = function OIGridFiller(grid) {
        $t.$baseType.ctor.call(this);
        this.grid = grid;
    };
    $p._visit$3 = function OIGridFiller__visit(shape) {
        shape.IXShape$forEachCellAbs($d.delegate(function(x, y, value) {
            this.grid.setCellValue(x, y, value);
        }, this));
    };
});
$d.define(RectShape, APolyShape, function($t, $p) {
    $t.$intfs = [IXShape];
    $t.ctor = function RectShape(topLeftVertex, cells) {
        $t.$baseType.ctor.call(this, topLeftVertex, cells);
    };
    $p.isCellValid = function RectShape_isCellValid(x, y) {
        return x >= 0 && x < this.grid().rows() && y >= 0 && y < this.grid().columns();
    };
    $p.IXShape$isCellValid = $p.isCellValid;
});
$d.define(ShapeCellularAutomaton, null, function($t, $p) {
    $t.$ator = function() {
        this.randomFillPercent = 0;
        this.seed = 0;
        this.smoothSteps = 0;
        this.intInRangePicker = null;
        this._logger = null;
    };
    $t.ctor = function ShapeCellularAutomaton(seed, randomFillPercent, smoothSteps) {
        $t.$baseType.ctor.call(this);
        this.seed = seed;
        this.randomFillPercent = randomFillPercent;
        this.smoothSteps = smoothSteps;

        this.intInRangePicker = new DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy.ctor(seed);
    };
    $p.setLogger = function ShapeCellularAutomaton_setLogger(logger) {
        this._logger = logger;
        this.intInRangePicker.setLogger(this._logger);
    };
    $p.applyOn = function ShapeCellularAutomaton_applyOn(shape) {
        shape.IXShape$forEachCell($d.delegate(this.RandomFillMap, this));
        for (var i = 0; i < this.smoothSteps; i++) {
            this.SmoothMap(shape);
        }

    };
    $p.RandomFillMap = function ShapeCellularAutomaton_RandomFillMap(row, col, shape) {
        var value = (this.intInRangePicker.drawBetween(0, 100) < this.randomFillPercent) ? XTile().FLOOR : XTile().WALL;
        shape.IXShape$setCellValue(row, col, value);
    };
    $p.SmoothMap = function ShapeCellularAutomaton_SmoothMap(shape) {
        shape.IXShape$forEachCell($d.delegate(function(row, col, sameShape) {
            var neighbourWallTiles = this.GetSurroundingWallCount(row, col, shape);
            if (neighbourWallTiles > 4)
                shape.IXShape$setCellValue(row, col, XTile().WALL);
            else if (neighbourWallTiles < 4)
                shape.IXShape$setCellValue(row, col, XTile().FLOOR);
        }, this));
    };
    $p.GetSurroundingWallCount = function ShapeCellularAutomaton_GetSurroundingWallCount(row, col, shape) {
        var wallCount = 0;
        for (var neighbourX = row - 1; neighbourX <= row + 1; neighbourX++) {
            for (var neighbourY = col - 1; neighbourY <= col + 1; neighbourY++) {
                if (shape.IXShape$isCellValid(neighbourX, neighbourY)) {
                    if (neighbourX != row || neighbourY != col) {
                        if (shape.IXShape$hasCellValue(neighbourX, neighbourY, XTile().WALL))
                            wallCount++;
                    }
                }
                else {
                    wallCount++;
                }
            }
        }
        return wallCount;
    };
});
$d.define(XTile, null, function($t, $p) {
    $t.cctor = function() {
        $t.WALL = 0;
        $t.FLOOR = 1;
    };
});
var ICaveBoardPlotter$1 = $g.ICaveBoardPlotter$1 = $d.type("ICaveBoardPlotter`1", 322, $asm, function($t, $p, TResult) {
}, ["TResult"]);
$d.define(ZeroOneCavePlotter, null, function($t, $p) {
    $t.$intfs = function() { return [ICaveBoardPlotter$1($d.arrayType(System.Int32, 2))]; };
    $t.$ator = function() {
        this._grid = null;
        this._OTHER_0 = 0;
        this._WALL_1 = 0;
    };
    $t.ctor = function ZeroOneCavePlotter() {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
        this._OTHER_0 = 0;
        this._WALL_1 = 1;
    };
    $p.applyOn = function ZeroOneCavePlotter_applyOn(board) {
        this._grid = new OIGrid.ctor$1(board.rows(), board.cols());

        var populated = new OIGrid.ctor$1(board.rows(), board.cols());
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++)
            (function() {
                var eachShape = $a[$i];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);
        for (var $i1 = 0, $a1 = board.corridors(), $length1 = $a1.length; $i1 < $length1; $i1++)
            (function() {
                var eachShape = $a1[$i1];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);

        var inverted = populated.invert();
        inverted.forEach2($d.delegate(function(row, col, value) {
            if (value == 1 && inverted.existsCellNeighborValue(row, col, 0)) {
                this._grid.setCellValue(row, col, 1);
            }
            else {
                this._grid.setCellValue(row, col, 0);
            }
        }, this));
    };
    $p.result = function ZeroOneCavePlotter_result() {
        return this._grid.asMatrix();
    };
    $p.ICaveBoardPlotter$1$applyOn = $p.applyOn;
    $p.ICaveBoardPlotter$1$result = $p.result;
});
$d.define(ZeroOneFillerCavePlotter, null, function($t, $p) {
    $t.$intfs = function() { return [ICaveBoardPlotter$1($d.arrayType(System.Int32, 2))]; };
    $t.$ator = function() {
        this._grid = null;
    };
    $t.ctor = function ZeroOneFillerCavePlotter() {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
    };
    $p.applyOn = function ZeroOneFillerCavePlotter_applyOn(board) {
        this._grid = new OIGrid.ctor$1(board.rows(), board.cols());
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++)
            (function() {
                var eachShape = $a[$i];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    this._grid.setCellValue(row, col, value);
                }, this));
            }).call(this);
        for (var $i1 = 0, $a1 = board.corridors(), $length1 = $a1.length; $i1 < $length1; $i1++)
            (function() {
                var eachShape = $a1[$i1];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    this._grid.setCellValue(row, col, value);
                }, this));
            }).call(this);
    };
    $p.result = function ZeroOneFillerCavePlotter_result() {
        return this._grid.asMatrix();
    };
    $p.ICaveBoardPlotter$1$applyOn = $p.applyOn;
    $p.ICaveBoardPlotter$1$result = $p.result;
});
$d.define(ZeroOneTwoFillerCavePlotter, null, function($t, $p) {
    $t.$intfs = function() { return [ICaveBoardPlotter$1($d.arrayType(System.Int32, 2))]; };
    $t.$ator = function() {
        this._grid = null;
    };
    $t.ctor = function ZeroOneTwoFillerCavePlotter() {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
    };
    $p.applyOn = function ZeroOneTwoFillerCavePlotter_applyOn(board) {
        this._grid = new OIGrid.ctor$1(board.rows(), board.cols());
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++)
            (function() {
                var eachShape = $a[$i];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    this._grid.setCellValue(row, col, value);
                }, this));
            }).call(this);
        for (var $i1 = 0, $a1 = board.corridors(), $length1 = $a1.length; $i1 < $length1; $i1++)
            (function() {
                var eachShape = $a1[$i1];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    this._grid.setCellValue(row, col, 2);
                }, this));
            }).call(this);
    };
    $p.result = function ZeroOneTwoFillerCavePlotter_result() {
        return this._grid.asMatrix();
    };
    $p.ICaveBoardPlotter$1$applyOn = $p.applyOn;
    $p.ICaveBoardPlotter$1$result = $p.result;
});
$d.define(DungeonGeneration.Generator.Domain.Board, null, function($t, $p) {
    $t.$ator = function() {
        this._grid = null;
        this._roomsAndCorridors = null;
        this._margin = 0;
    };
    $t.ctor$2 = function Board(rows, columns) {
        $t.ctor$3.call(this, rows, columns, 0);
    };
    $t.ctor$3 = function Board(rows, columns, margin) {
        $t.ctor$1.call(this, new DungeonGeneration.Generator.Domain.Grid.ctor(rows, columns), margin);
    };
    $t.ctor = function Board(mapGrid) {
        $t.ctor$1.call(this, mapGrid, 0);
    };
    $t.ctor$1 = function Board(mapGrid, margin) {
        $t.$baseType.ctor.call(this);
        this._grid = mapGrid;
        this._roomsAndCorridors = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.IShape, 
            54824).ctor)();
        this._margin = margin;
    };
    $p.fitsIn = function Board_fitsIn(aSquare) {
        if (!aSquare.DungeonGeneration$Generator$Domain$IShape$isWithin(this._grid))
            return false;
        for (var i = 0; i < this._roomsAndCorridors.get_Count() - 1; i++) {
            var each = this._roomsAndCorridors.get_Item(i);
            if (aSquare.DungeonGeneration$Generator$Domain$IShape$collidesWith(each))
                return false;
        }
        return true;
    };
    $p.addRoom = function Board_addRoom(aRoom) {
        if (this._roomsAndCorridors.get_Count() != 0) {
            var corr = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1), 
                Corridor);
            corr.setDestinationRoom(aRoom);
            aRoom.setCorridorIncoming(corr);
        }
        this._roomsAndCorridors.Add(aRoom);
    };
    $p.asTilesMatrix = function Board_asTilesMatrix(plotter) {
        var result = $d.array(System.Int32, this._grid.rows() * this._grid.columns(), [this._grid.rows(), 
            this._grid.columns()]);

        if (this._roomsAndCorridors.get_Count() > 0) {
            this._roomsAndCorridors.get_Item(0).DungeonGeneration$Generator$Domain$IShape$plotOn(result, 
                plotter);
        }
        return result;
    };
    $p.addCorridor = function Board_addCorridor(corr) {
        if (this._roomsAndCorridors.get_Count() != 0) {
            var room = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1), 
                Room);
            room.setCorridorOutcoming(corr);
            corr.setSourceRoom(room);
        }
        this._roomsAndCorridors.Add(corr);
    };
    $p.removeLast = function Board_removeLast() {
        if (this._roomsAndCorridors.get_Count() == 0)
            return;

        var last = this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1);
        var beforeLast = null;
        if (this._roomsAndCorridors.get_Count() >= 2) {
            beforeLast = this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 2);
        }

        if ($d.is(last, Room)) {
            var room = $d.cast(last, Room);
            room.setCorridorIncoming(null);
            if (beforeLast != null) {
                var corr = $d.cast(beforeLast, Corridor);
                corr.setDestinationRoom(null);
            }
        }
        else {
            var corr = $d.cast(last, Corridor);
            corr.setSourceRoom(null);
            if (beforeLast != null) {
                var room = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 2), 
                    Room);
                room.setCorridorOutcoming(null);
            }
        }
        this._roomsAndCorridors.RemoveAt(this._roomsAndCorridors.get_Count() - 1);
    };
    $p.resize = function Board_resize(mapMargin) {
        if (mapMargin < 0)
            return this;

        var resized = new DungeonGeneration.Generator.Domain.Board.ctor$2(this.rows() + mapMargin * 2, 
            this.cols() + mapMargin * 2);
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Room)) {
                var r = $d.cast(each, Room);
                var vert = r.topLeftVertex().plusCell(mapMargin, mapMargin);
                var relocated = new Room.ctor(vert, r.grid());
                resized.addRoom(relocated);
            }
            else {
                var c = $d.cast(each, Corridor);
                var vert = c.topLeftVertex().plusCell(mapMargin, mapMargin);
                var orient = c.isOrizontal() ? 0 : 1;
                var relocated = new Corridor.ctor(vert, c.grid(), orient);
                resized.addCorridor(relocated);
            }
        }
        return resized;
    };
    $p.crop = function Board_crop() {
        return this.crop$1(0);
    };
    $p.crop$1 = function Board_crop(marginToAddAfterCrop) {
        var upperTopLeftVert = null;
        var righterBottomRightVert = null;
        var downerBottomRightVert = null;
        var lefterTopLeftVert = null;
        for (var $i = 0, $a = this.rooms(), $length = $a.length; $i < $length; $i++) {
            var each = $a[$i];
            if (upperTopLeftVert == null) {
                upperTopLeftVert = each.topLeftVertex();
                righterBottomRightVert = each.bottomRightVertex();
                downerBottomRightVert = righterBottomRightVert;
                lefterTopLeftVert = upperTopLeftVert;
            }
            else {
                if (each.topLeftVertex().isRowLesserThan(upperTopLeftVert)) {
                    upperTopLeftVert = each.topLeftVertex();
                }
                if (each.bottomRightVertex().isColGreatherThan(righterBottomRightVert)) {
                    righterBottomRightVert = each.bottomRightVertex();
                }
                if (each.bottomRightVertex().isRowGreatherThan(downerBottomRightVert)) {
                    downerBottomRightVert = each.bottomRightVertex();
                }
                if (each.topLeftVertex().isColLesserThan(lefterTopLeftVert)) {
                    lefterTopLeftVert = each.topLeftVertex();
                }
            }
        }

        var rows = downerBottomRightVert.row() - upperTopLeftVert.row() + 1 + marginToAddAfterCrop * 2;
        var cols = righterBottomRightVert.col() - lefterTopLeftVert.col() + 1 + marginToAddAfterCrop * 2;

        var cropUp = upperTopLeftVert.row() - marginToAddAfterCrop;
        var cropLeft = lefterTopLeftVert.col() - marginToAddAfterCrop;

        var cropped = new DungeonGeneration.Generator.Domain.Board.ctor$2(rows, cols);
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Room)) {
                var r = $d.cast(each, Room);
                var vert = r.topLeftVertex().minus(cropUp, cropLeft);
                var relocated = new Room.ctor(vert, r.grid());
                cropped.addRoom(relocated);
            }
            else {
                var c = $d.cast(each, Corridor);
                var vert = c.topLeftVertex().minus(cropUp, cropLeft);
                var orient = c.isOrizontal() ? 0 : 1;
                var relocated = new Corridor.ctor(vert, c.grid(), orient);
                cropped.addCorridor(relocated);
            }
        }
        return cropped;
    };
    $p.cols = function Board_cols() {
        return this._grid.columns();
    };
    $p.rows = function Board_rows() {
        return this._grid.rows();
    };
    $p.numberOfRoomsAndCorridors = function Board_numberOfRoomsAndCorridors() {
        return this._roomsAndCorridors.get_Count();
    };
    $p.rooms = function Board_rooms() {
        var result = new (System.Collections.Generic.List$1(Room, 41451).ctor)();
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Room))
                result.Add($d.cast(each, Room));
        }
        return result.ToArray();
    };
    $p.corridors = function Board_corridors() {
        var result = new (System.Collections.Generic.List$1(Corridor, 53384).ctor)();
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Corridor))
                result.Add($d.cast(each, Corridor));
        }
        return result.ToArray();
    };
    $p.roomSize = function Board_roomSize() {
        return this.rooms().length;
    };
});
$d.define(DungeonGeneration.Generator.Domain.Cell, null, function($t, $p) {
    $t.$ator = function() {
        this._row = 0;
        this._col = 0;
    };
    $t.ctor = function Cell(aRow, aCol) {
        $t.$baseType.ctor.call(this);
        this._row = aRow;
        this._col = aCol;
    };
    $p.Equals = function Cell_Equals(obj) {
        return this.isEqual($d.cast(obj, DungeonGeneration.Generator.Domain.Cell));
    };
    $p.ToString = function Cell_ToString() {
        return "Cell: [" + $d.toString(this._row) + ", " + $d.toString(this._col) + "]";
    };
    $p.GetHashCode = function Cell_GetHashCode() {
        return this.toString().GetHashCode();
    };
    $p.hasNegativeIndexes = function Cell_hasNegativeIndexes() {
        if (this._row < 0)
            return true;
        if (this._col < 0)
            return true;
        return false;
    };
    $p.toNearestPositiveCell = function Cell_toNearestPositiveCell() {
        var row = this._row < 0 ? 0 : this._row;
        var col = this._col < 0 ? 0 : this._col;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(row, col);
    };
    $p.distance = function Cell_distance(other) {
        var rowDistance = System.Math.Abs(this._row - other._row) + 1;

        var colDistance = System.Math.Abs(this._col - other._col) + 1;
        return rowDistance * colDistance;
    };
    $p.hasSameRow = function Cell_hasSameRow(other) {
        return this._row == other._row;
    };
    $p.hasSameColumn = function Cell_hasSameColumn(other) {
        return this._col == other._col;
    };
    $p.isWithin$1 = function Cell_isWithin(start, end) {
        if (this._row < start._row)
            return false;
        if (this._col < start._col)
            return false;
        if (this._row > end._row)
            return false;
        if (this._col > end._col)
            return false;
        return true;
    };
    $p.isWithin = function Cell_isWithin(aGrid) {
        return aGrid.hasCell(this._row, this._col);
    };
    $p.row = function Cell_row() {
        return this._row;
    };
    $p.col = function Cell_col() {
        return this._col;
    };
    $p.isEqual = function Cell_isEqual(other) {
        if (other._row != this._row)
            return false;
        if (other._col != this._col)
            return false;
        return true;
    };
    $p.plusCell = function Cell_plusCell(rowCells, colCells) {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row + rowCells, this._col + colCells);
    };
    $p.minusCell = function Cell_minusCell(rowCells, colCells) {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row - rowCells, this._col - colCells);
    };
    $p.minusSize = function Cell_minusSize(rowSize, colSize) {
        if (rowSize == 0)
            rowSize = 1;
        if (colSize == 0)
            colSize = 1;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row - (rowSize - 1), this._col - (colSize - 1));
    };
    $p.plusSize = function Cell_plusSize(rowSize, colSize) {
        if (rowSize == 0)
            rowSize = 1;
        if (colSize == 0)
            colSize = 1;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row + (rowSize - 1), this._col + (colSize - 1));
    };
    $p.cells = function Cell_cells(other) {
        var min = this;
        var max = other;
        if (this.isGreatherThan(other)) {
            min = other;
            max = this;
        }

        var cellsNumber = this.distance(other);
        var result = $d.array(DungeonGeneration.Generator.Domain.Cell, cellsNumber);

        var cellIndex = 0;
        for (var row = min._row; row <= max._row; row++) {
            for (var col = min._col; col <= max._col; col++) {
                result[cellIndex] = new DungeonGeneration.Generator.Domain.Cell.ctor(row, col);
                cellIndex++;
            }
        }
        return result;
    };
    $p.isLesserThan = function Cell_isLesserThan(other) {
        var distanceA = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(this);
        var distanceB = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(other);
        return distanceA < distanceB;
    };
    $p.isRowLesserThan = function Cell_isRowLesserThan(other) {
        return this.row() < other.row();
    };
    $p.isColLesserThan = function Cell_isColLesserThan(other) {
        return this.col() < other.col();
    };
    $p.isGreatherThan = function Cell_isGreatherThan(other) {
        var distanceA = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(this);
        var distanceB = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(other);
        return distanceA > distanceB;
    };
    $p.isRowGreatherThan = function Cell_isRowGreatherThan(other) {
        return this.row() > other.row();
    };
    $p.isColGreatherThan = function Cell_isColGreatherThan(other) {
        return this.col() > other.col();
    };
    $p.minus = function Cell_minus(v1, v2) {
        return this.minusCell(v1, v2);
    };
    $p.magnetude = function Cell_magnetude(other) {
        var diffY = System.Math.Abs(this.row()) - System.Math.Abs(other.row());
        var diffX = System.Math.Abs(this.col()) - System.Math.Abs(other.col());
        var sum = ((System.Math.Pow(diffY, 2) + System.Math.Pow(diffX, 2)) | 0);
        return System.Math.Round$1(System.Math.Sqrt(sum), 2);
    };
    $p.plus = function Cell_plus(cell) {
        return this.plusCell(cell.row(), cell.col());
    };
});
DungeonGeneration.Generator.Domain.IShape = $d.type("DungeonGeneration.Generator.Domain.IShape", 66, $asm, function($t, $p) {
});
$d.define(Corridor, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Domain.IShape];
    $t.$ator = function() {
        this._topLeftVertex = null;
        this._topRightVertex = null;
        this._botLeftVertex = null;
        this._botRightVertex = null;
        this._grid = null;
        this._orientation = 0;
        this._sourceRoom = null;
        this._destRoom = null;
    };
    $t.Orientation = $d.typeEnum("Orientation", 45, $t, 258, ["horizontal", "vertical"], [0, 1]);
    $t.ctor = function Corridor(topLeftVertex, size, orientation) {
        $t.$baseType.ctor.call(this);
        this._topLeftVertex = topLeftVertex;
        this._topRightVertex = size.absTopRightVertexUsing(this._topLeftVertex);
        this._botLeftVertex = size.absBotLeftVertexUsing(this._topLeftVertex);
        this._botRightVertex = size.absBotRightVertexUsing(this._topLeftVertex);
        this._grid = size;
        this._orientation = orientation;
    };
    $p.isCellPerimetral = function Corridor_isCellPerimetral(pos) {
        if (pos.isWithin$1(this.topLeftVertex(), this.topRightVertex()))
            return true;
        if (pos.isWithin$1(this.topRightVertex(), this.bottomRightVertex()))
            return true;
        if (pos.isWithin$1(this.bottomLeftVertex(), this.bottomRightVertex()))
            return true;
        if (pos.isWithin$1(this.topLeftVertex(), this.bottomLeftVertex()))
            return true;
        return false;
    };
    $p.plotOn = function Corridor_plotOn(map, plotter) {
        if (this.hasDestRoom())
            this.destRoom().plotOn(map, plotter);
        plotter.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnCorridor(this, map);
    };
    $p.bottomRightVertex = function Corridor_bottomRightVertex() {
        return this._botRightVertex;
    };
    $p.topRightVertex = function Corridor_topRightVertex() {
        return this._topRightVertex;
    };
    $p.topLeftVertex = function Corridor_topLeftVertex() {
        return this._topLeftVertex;
    };
    $p.setDestinationRoom = function Corridor_setDestinationRoom(room) {
        this._destRoom = room;
    };
    $p.width = function Corridor_width() {
        return this._grid.columns();
    };
    $p.bottomLeftVertex = function Corridor_bottomLeftVertex() {
        return this._botLeftVertex;
    };
    $p.setSourceRoom = function Corridor_setSourceRoom(room) {
        this._sourceRoom = room;
    };
    $p.height = function Corridor_height() {
        return this._grid.rows();
    };
    $p.isVertical = function Corridor_isVertical() {
        return this._orientation == 1;
    };
    $p.isOrizontal = function Corridor_isOrizontal() {
        return this._orientation == 0;
    };
    $p.isSharingVertex = function Corridor_isSharingVertex(vertex) {
        if (vertex.isEqual(this._topLeftVertex))
            return true;
        if (vertex.isEqual(this._topRightVertex))
            return true;
        if (vertex.isEqual(this._botLeftVertex))
            return true;
        if (vertex.isEqual(this._botRightVertex))
            return true;
        return false;
    };
    $p.isWithin = function Corridor_isWithin(container) {
        return this._grid.isWithin(container, this._topLeftVertex);
    };
    $p.isSharingBottomLeftVertexWithSourceRoom = function Corridor_isSharingBottomLeftVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.bottomLeftVertex());
    };
    $p.isSharingBottomRightVertexWithSourceRoom = function Corridor_isSharingBottomRightVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.bottomRightVertex());
    };
    $p.isSharingTopLeftVertexWithSourceRoom = function Corridor_isSharingTopLeftVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.topLeftVertex());
    };
    $p.isSharingTopRightVertexWithSourceRoom = function Corridor_isSharingTopRightVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.topRightVertex());
    };
    $p.isSharingBottomLeftVertexWithDestRoom = function Corridor_isSharingBottomLeftVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.bottomLeftVertex());
    };
    $p.isSharingBottomRightVertexWithDestRoom = function Corridor_isSharingBottomRightVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.bottomRightVertex());
    };
    $p.isSharingTopLeftVertexWithDestRoom = function Corridor_isSharingTopLeftVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.topLeftVertex());
    };
    $p.isSharingTopRightVertexWithDestRoom = function Corridor_isSharingTopRightVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.topRightVertex());
    };
    $p.hasSourceRoom = function Corridor_hasSourceRoom() {
        return this.sourceRoom() != null;
    };
    $p.hasDestRoom = function Corridor_hasDestRoom() {
        return this.destRoom() != null;
    };
    $p.sourceRoom = function Corridor_sourceRoom() {
        return this._sourceRoom;
    };
    $p.destRoom = function Corridor_destRoom() {
        return this._destRoom;
    };
    $p.collidesWith = function Corridor_collidesWith(each) {
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._topLeftVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._topRightVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._botRightVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._botLeftVertex))
            return true;
        return false;
    };
    $p.containsCell = function Corridor_containsCell(aCell) {
        return aCell.isWithin$1(this._topLeftVertex, this._botRightVertex);
    };
    $p.ToString = function Corridor_ToString() {
        return "Corridor: " + $d.toString(this.topLeftVertex()) + " " + $d.toString(this._grid);
    };
    $p.walkableCells = function Corridor_walkableCells() {
        var innerA = null;
        var innerB = null;
        if (this.isOrizontal()) {
            innerA = this.topLeftVertex().plusCell(1, 0);
            innerB = this.bottomRightVertex().minusCell(1, 0);
        }
        else {
            innerA = this.topLeftVertex().plusCell(0, 1);
            innerB = this.bottomRightVertex().minusCell(0, 1);
        }
        return innerA.cells(innerB);
    };
    $p.grid = function Corridor_grid() {
        return this._grid;
    };
    $p.DungeonGeneration$Generator$Domain$IShape$isWithin = $p.isWithin;
    $p.DungeonGeneration$Generator$Domain$IShape$collidesWith = $p.collidesWith;
    $p.DungeonGeneration$Generator$Domain$IShape$containsCell = $p.containsCell;
    $p.DungeonGeneration$Generator$Domain$IShape$plotOn = $p.plotOn;
});
$d.define(Room, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Domain.IShape];
    $t.$ator = function() {
        this._grid = null;
        this._topLeftVertex = null;
        this._topRightVertex = null;
        this._botLeftVertex = null;
        this._botRightVertex = null;
        this._outcomingCorridor = null;
        this._incomingCorridor = null;
    };
    $t.ctor = function Room(topLeftVertex, size) {
        $t.$baseType.ctor.call(this);
        this._topLeftVertex = topLeftVertex;
        this._topRightVertex = size.absTopRightVertexUsing(this._topLeftVertex);
        this._botLeftVertex = size.absBotLeftVertexUsing(this._topLeftVertex);
        this._botRightVertex = size.absBotRightVertexUsing(this._topLeftVertex);
        this._grid = size;
    };
    $p.setCorridorIncoming = function Room_setCorridorIncoming(corr) {
        this._incomingCorridor = corr;
    };
    $p.setCorridorOutcoming = function Room_setCorridorOutcoming(corr) {
        this._outcomingCorridor = corr;
    };
    $p.topRightVertex = function Room_topRightVertex() {
        return this._topRightVertex;
    };
    $p.bottomLeftVertex = function Room_bottomLeftVertex() {
        return this._botLeftVertex;
    };
    $p.topLeftVertex = function Room_topLeftVertex() {
        return this._topLeftVertex;
    };
    $p.bottomRightVertex = function Room_bottomRightVertex() {
        return this._botRightVertex;
    };
    $p.ToString = function Room_ToString() {
        return "Room: " + $d.toString(this.topLeftVertex()) + " " + $d.toString(this._grid);
    };
    $p.plotOn = function Room_plotOn(map, plotter) {
        plotter.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnRoom(this, map);
        if (this._outcomingCorridor != null)
            this._outcomingCorridor.plotOn(map, plotter);
    };
    $p.hasCorridorSharingVertex = function Room_hasCorridorSharingVertex(vertex) {
        var result = false;
        if (this._incomingCorridor != null) {
            result = result || this._incomingCorridor.isSharingVertex(vertex);
        }
        if (this._outcomingCorridor != null) {
            result = result || this._outcomingCorridor.isSharingVertex(vertex);
        }
        return result;
    };
    $p.height = function Room_height() {
        return this._grid.rows();
    };
    $p.width = function Room_width() {
        return this._grid.columns();
    };
    $p.isSharingVertex = function Room_isSharingVertex(vertex) {
        if (vertex.isEqual(this._topLeftVertex))
            return true;
        if (vertex.isEqual(this._topRightVertex))
            return true;
        if (vertex.isEqual(this._botLeftVertex))
            return true;
        if (vertex.isEqual(this._botRightVertex))
            return true;
        return false;
    };
    $p.isWithin = function Room_isWithin(container) {
        return this._grid.isWithin(container, this._topLeftVertex);
    };
    $p.collidesWith = function Room_collidesWith(other) {
        var cells = this._topLeftVertex.cells(this._botRightVertex);
        for (var $i = 0, $length = cells.length; $i < $length; $i++) {
            var each = cells[$i];
            if (other.DungeonGeneration$Generator$Domain$IShape$containsCell(each))
                return true;
        }
        return false;
    };
    $p.containsCell = function Room_containsCell(aCell) {
        return aCell.isWithin$1(this._topLeftVertex, this._botRightVertex);
    };
    $p.walkableCells = function Room_walkableCells() {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        var innerTopLeft = this.topLeftVertex().plusCell(1, 1);
        var innerBotRight = this.bottomRightVertex().minusCell(1, 1);
        result.AddRange(innerTopLeft.cells(innerBotRight));
        return result.ToArray();
    };
    $p.hasCorridorAtEast = function Room_hasCorridorAtEast() {
        return this.isEast(this._incomingCorridor) || this.isEast(this._outcomingCorridor);
    };
    $p.hasCorridorAtSouth = function Room_hasCorridorAtSouth() {
        return this.isSouth(this._incomingCorridor) || this.isSouth(this._outcomingCorridor);
    };
    $p.hasCorridorAtWest = function Room_hasCorridorAtWest() {
        return this.isWest(this._incomingCorridor) || this.isWest(this._outcomingCorridor);
    };
    $p.hasCorridorAtNorth = function Room_hasCorridorAtNorth() {
        return this.isNorth(this._incomingCorridor) || this.isNorth(this._outcomingCorridor);
    };
    $p.isNorth = function Room_isNorth(corr) {
        if (corr == null)
            return false;
        return corr.bottomLeftVertex().isWithin$1(this.topLeftVertex(), this.topRightVertex());
    };
    $p.isWest = function Room_isWest(corr) {
        if (corr == null)
            return false;
        return corr.topRightVertex().isWithin$1(this.topLeftVertex(), this.bottomLeftVertex());
    };
    $p.isSouth = function Room_isSouth(corr) {
        if (corr == null)
            return false;
        return corr.topLeftVertex().isWithin$1(this.bottomLeftVertex(), this.bottomRightVertex());
    };
    $p.isEast = function Room_isEast(corr) {
        if (corr == null)
            return false;
        return corr.topLeftVertex().isWithin$1(this.topRightVertex(), this.bottomRightVertex());
    };
    $p.cellsFacingOutcomingCorridor = function Room_cellsFacingOutcomingCorridor() {
        return this.cellFacingCorridor(this._outcomingCorridor);
    };
    $p.cellsFacingIncomingCorridor = function Room_cellsFacingIncomingCorridor() {
        return this.cellFacingCorridor(this._incomingCorridor);
    };
    $p.cellFacingCorridor = function Room_cellFacingCorridor(corr) {
        if (corr == null)
            return $d.array(DungeonGeneration.Generator.Domain.Cell, 0);

        var vertex1 = null;
        var vertex2 = null;
        if (this.isEast(corr)) {
            vertex1 = corr.topLeftVertex().plusCell(1, -1);
            vertex2 = corr.bottomLeftVertex().minusCell(1, 1);
        }
        else if (this.isSouth(corr)) {
            vertex1 = corr.topLeftVertex().plusCell(-1, 1);
            vertex2 = corr.topRightVertex().minusCell(1, 1);
        }
        else if (this.isWest(corr)) {
            vertex1 = corr.topRightVertex().plusCell(1, 1);
            vertex2 = corr.bottomRightVertex().minusCell(1, -1);
        }
        else if (this.isNorth(corr)) {
            vertex1 = corr.bottomLeftVertex().plusCell(1, 1);
            vertex2 = corr.bottomRightVertex().plusCell(1, -1);
        }
        return vertex1.cells(vertex2);
    };
    $p.grid = function Room_grid() {
        return this._grid;
    };
    $p.DungeonGeneration$Generator$Domain$IShape$isWithin = $p.isWithin;
    $p.DungeonGeneration$Generator$Domain$IShape$collidesWith = $p.collidesWith;
    $p.DungeonGeneration$Generator$Domain$IShape$containsCell = $p.containsCell;
    $p.DungeonGeneration$Generator$Domain$IShape$plotOn = $p.plotOn;
});
$d.define(DungeonGeneration.Generator.DungeonGenerator, null, function($t, $p) {
    $t.$ator = function() {
        this._corridorLengthMin = 0;
        this._corridorLengthMax = 0;
        this._corridorWidthMin = 0;
        this._corridorWidthMax = 0;
        this._roomSizeMin = 0;
        this._roomSizeMax = 0;
        this._roomsNumberMin = 0;
        this._roomsNumberMax = 0;
        this._seed = 0;
        this._mapRows = 0;
        this._mapColumns = 0;
        this._logger = null;
        this._plotter = null;
        this._board = null;
        this._mapMargin = 0;
        this._mapCropEnabled = false;
    };
    $t.ctor = function DungeonGenerator() {
        $t.$baseType.ctor.call(this);
        this._logger = new DungeonGeneration.Logging.NullLogger.ctor();

        this._corridorWidthMin = 3;
        this._corridorWidthMax = 3;
        this._mapMargin = 0;
        this._mapCropEnabled = false;
        this.clearBoard();
    };
    $p.getMinRoomSize = function DungeonGenerator_getMinRoomSize() {
        return this._roomsNumberMin;
    };
    $p.getSeed = function DungeonGenerator_getSeed() {
        return this._seed;
    };
    $p.getLogger = function DungeonGenerator_getLogger() {
        return this._logger;
    };
    $p.setBoard = function DungeonGenerator_setBoard(board) {
        this._board = board;
    };
    $p.clearBoard = function DungeonGenerator_clearBoard() {
        this._board = null;
    };
    $p.isBoardCleared = function DungeonGenerator_isBoardCleared() {
        return this._board == null;
    };
    $p.setCorridorLengthRange = function DungeonGenerator_setCorridorLengthRange(v1, v2) {
        this._corridorLengthMin = v1;
        this._corridorLengthMax = v2;
        this.clearBoard();
    };
    $p.setCorridorWidthRange = function DungeonGenerator_setCorridorWidthRange(v1, v2) {
        this._corridorWidthMin = v1;
        this._corridorWidthMax = v2;
        this.clearBoard();
    };
    $p.setRoomSizeRange = function DungeonGenerator_setRoomSizeRange(v1, v2) {
        this._roomSizeMin = v1;
        this._roomSizeMax = v2;
        this.clearBoard();
    };
    $p.setRoomsNumberRange = function DungeonGenerator_setRoomsNumberRange(v1, v2) {
        this._roomsNumberMin = v1;
        this._roomsNumberMax = v2;
        this.clearBoard();
    };
    $p.setSeed = function DungeonGenerator_setSeed(v) {
        this._seed = v;
        this.clearBoard();
    };
    $p.setMapSize = function DungeonGenerator_setMapSize(rows, columns) {
        this._mapRows = rows;
        this._mapColumns = columns;
        this.clearBoard();
    };
    $p.setLogger = function DungeonGenerator_setLogger(logger) {
        this._logger = logger;
        this.clearBoard();
    };
    $p.asBoard = function DungeonGenerator_asBoard() {
        this.checkConstraints();
        if (!this.isBoardCleared())
            return this._board;
        this._board = new DungeonGeneration.Generator.Domain.Board.ctor$2(this._mapRows - this._mapMargin * 2, 
            this._mapColumns - this._mapMargin * 2);

        var seedStrategy = new DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy.ctor(this._seed);
        seedStrategy.setLogger(this._logger);

        var roomNumberPicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._roomsNumberMin, 
            this._roomsNumberMax, seedStrategy);
        var roomSizePicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._roomSizeMin, 
            this._roomSizeMax, seedStrategy);
        var corrLengthPicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._corridorLengthMin, 
            this._corridorLengthMax, seedStrategy);
        var corrWidthPicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._corridorWidthMin, 
            this._corridorWidthMax, seedStrategy);
        var cardPointPicker = new DungeonGeneration.Generator.Pickers.CardinalPointPicker.ctor(seedStrategy);
        var cellRangePicker = new DungeonGeneration.Generator.Pickers.CellInRangePicker.ctor(seedStrategy);

        var roomNumber = roomNumberPicker.draw();
        if (roomNumber < 1) {
            this._logger.DungeonGeneration$Logging$IXLogger$warning("Room number should be at least 1. Instead is: " + $d.toString(roomNumber));
            return this._board;
        }

        var grid = new DungeonGeneration.Generator.Domain.Grid.ctor(roomSizePicker.draw(), roomSizePicker.draw());
        var topLeftVertexMin = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0);
        var topLeftVertexMax = new DungeonGeneration.Generator.Domain.Cell.ctor(this._board.rows() - 1, 
            this._board.cols() - 1).minusSize(grid.rows(), grid.columns());
        var topLeftCell = cellRangePicker.drawBetween(topLeftVertexMin, topLeftVertexMax);
        var lastRoom = new Room.ctor(topLeftCell, grid);
        if (!this._board.fitsIn(lastRoom)) {
            this._logger.DungeonGeneration$Logging$IXLogger$error("First room not fit in. This should never happen");
            return this._board;
        }
        this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(lastRoom));
        this._board.addRoom(lastRoom);

        var lastDirection = 0;
        var roomCreationAttempt = 1;
        for (var i = 1; i < roomNumber; i++) {
            if (roomCreationAttempt == 1) {
                lastDirection = cardPointPicker.draw();
            }
            else {
                lastDirection = cardPointPicker.nextClockwise(lastDirection);
            }

            var cardinalPointAttempt = 1;
            var lastCorridor = null;
            do {
                lastCorridor = this.generateCorridor(lastDirection, lastRoom, corrLengthPicker, corrWidthPicker, 
                    cellRangePicker);
                if (!this._board.fitsIn(lastCorridor)) {
                    this._logger.DungeonGeneration$Logging$IXLogger$info("NO FITS: " + $d.toString(lastCorridor) + " " + $d.toString($d.boxEnum(DungeonGeneration.Generator.Pickers.CardinalPoint, 
                        lastDirection)));
                    lastCorridor = null;
                    cardinalPointAttempt++;
                    lastDirection = cardPointPicker.nextClockwise(lastDirection);
                }
            }
            while (cardinalPointAttempt <= 4 && lastCorridor == null);

            if (lastCorridor == null) {
                this._logger.DungeonGeneration$Logging$IXLogger$warning("PROCEDURAL GENERATION INTERRUPTED: No more chance for a Corridor to fit in");
                break;
            }
            this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(lastCorridor) + " " + $d.toString($d.boxEnum(DungeonGeneration.Generator.Pickers.CardinalPoint, 
                lastDirection)));
            this._board.addCorridor(lastCorridor);

            var newRoom = this.generateRoom(lastDirection, lastCorridor, roomSizePicker, cellRangePicker);
            if (!this._board.fitsIn(newRoom)) {
                this._board.removeLast();
                if (roomCreationAttempt <= 4) {
                    this._logger.DungeonGeneration$Logging$IXLogger$info("NO FITS: " + $d.toString(newRoom) + " Retry: " + $d.toString(roomCreationAttempt));
                    roomCreationAttempt++;
                    i--;
                    continue;
                }
                else {
                    this._logger.DungeonGeneration$Logging$IXLogger$warning("PROCEDURAL GENERATION INTERRUPTED: No more chance for a Room to fit in");
                    break;
                }
            }
            else {
                this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(newRoom) + " Retry: " + $d.toString(roomCreationAttempt));
                lastRoom = newRoom;
                roomCreationAttempt = 1;
                this._board.addRoom(lastRoom);
            }
        }

        if (this._mapMargin > 0) {
            this._board = this._board.resize(this._mapMargin);
        }
        if (this._mapCropEnabled) {
            this._board = this._board.crop$1(this._mapMargin);
        }
        return this._board;
    };
    $p.checkConstraints = function DungeonGenerator_checkConstraints() {
        if (this._roomsNumberMax < this._roomsNumberMin)
            throw new System.FormatException.ctor$1("Invalid Room Number: Max < Min");
        if (this._roomSizeMax < this._roomSizeMin)
            throw new System.FormatException.ctor$1("Invalid Room Size: Max < Min");
        if (this._corridorLengthMax < this._corridorLengthMin)
            throw new System.FormatException.ctor$1("Invalid Corridor Length: Max < Min");
        if (this._corridorWidthMax < this._corridorWidthMin)
            throw new System.FormatException.ctor$1("Invalid Corridor Width: Max < Min");
        if (this._corridorWidthMax > this._roomSizeMin)
            throw new System.FormatException.ctor$1("Invalid Corridor Width Max > Room Size Min");
    };
    $p.setMapCropEnabled = function DungeonGenerator_setMapCropEnabled(enabled) {
        this._mapCropEnabled = enabled;
        this.clearBoard();
    };
    $p.setMapMargin = function DungeonGenerator_setMapMargin(mapMargin) {
        this._mapMargin = mapMargin;
        this.clearBoard();
    };
    $p.asMatrix = function DungeonGenerator_asMatrix() {
        return this.asBoard().asTilesMatrix(this._plotter);
    };
    $p.setPlotter = function DungeonGenerator_setPlotter(plotter) {
        this._plotter = plotter;
    };
    $p.generateRoom = function DungeonGenerator_generateRoom(lastCorridorDirection, lastCorr, roomSizePicker, cellInRangePicker) {
        var roomRows = roomSizePicker.draw();
        var roomCols = roomSizePicker.draw();
        var grid = new DungeonGeneration.Generator.Domain.Grid.ctor(roomRows, roomCols);
        var topLeftCell = null;
        if (lastCorridorDirection == 0) {
            var topLeftVertexMax = lastCorr.topLeftVertex().minusSize(roomRows, 0);
            var topLeftVertexMin = topLeftVertexMax.minusCell(0, roomCols - lastCorr.width());
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 1) {
            var topLeftVertexMax = lastCorr.topRightVertex();
            var topLeftVertexMin = topLeftVertexMax.minusCell(roomRows - lastCorr.height(), 0);
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 2) {
            var topLeftVertexMax = lastCorr.bottomLeftVertex();
            var topLeftVertexMin = topLeftVertexMax.minusCell(0, roomCols - lastCorr.width());
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 3) {
            var topLeftVertexMax = lastCorr.topLeftVertex().minusSize(0, roomCols);
            var topLeftVertexMin = topLeftVertexMax.minusCell(roomRows - lastCorr.height(), 0);
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        return new Room.ctor(topLeftCell, grid);
    };
    $p.generateCorridor = function DungeonGenerator_generateCorridor(mapDirection, lastRoom, corrLengthPicker, corrWidthPicker, cellRangePicker) {
        var corridorLenght = corrLengthPicker.draw();
        var corridorSection = corrWidthPicker.draw();

        var corrOrient = 0;
        var grid = null;
        var topLeftCell = lastRoom.topLeftVertex();
        if (mapDirection == 0) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorLenght, corridorSection);
            corrOrient = 1;
            var topLeftVertexMin = lastRoom.topLeftVertex().minusSize(corridorLenght, 0);
            var topLeftVertexMax = topLeftVertexMin.plusCell(0, lastRoom.width() - corridorSection);
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 1) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorSection, corridorLenght);
            corrOrient = 0;
            var topLeftVertexMin = lastRoom.topRightVertex();
            var topLeftVertexMax = topLeftVertexMin.plusCell(lastRoom.height() - corridorSection, 0);
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 2) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorLenght, corridorSection);
            corrOrient = 1;
            var topLeftVertexMin = lastRoom.bottomLeftVertex();
            var topLeftVertexMax = topLeftVertexMin.plusCell(0, lastRoom.width() - corridorSection);
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 3) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorSection, corridorLenght);
            corrOrient = 0;
            var topLeftVertexMin = lastRoom.topLeftVertex().minusSize(0, corridorLenght);
            var topLeftVertexMax = topLeftVertexMin.plusCell(lastRoom.height() - corridorSection, 0);
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        return new Corridor.ctor(topLeftCell, grid, corrOrient);
    };
});
$d.define(DungeonGeneration.Generator.ForcedDungeonGenerator, DungeonGeneration.Generator.DungeonGenerator, function($t, $p) {
    $t.$ator = function() {
        this._maxAttempts = 0;
    };
    $t.ctor = function ForcedDungeonGenerator(maxAttempts) {
        $t.$baseType.ctor.call(this);
        this._maxAttempts = maxAttempts;
    };
    $p.asBoard = function ForcedDungeonGenerator_asBoard() {
        if (!$t.$baseType.prototype.isBoardCleared.call(this))
            return $t.$baseType.prototype.asBoard.call(this);

        var bestBoard = null;
        var count = 1;
        while (count < this._maxAttempts) {
            $t.$baseType.prototype.getLogger.call(this).DungeonGeneration$Logging$IXLogger$info("Board generation attempt: " + $d.toString(count) + "/" + $d.toString(this._maxAttempts));

            var board = $t.$baseType.prototype.asBoard.call(this);
            if (bestBoard == null)
                bestBoard = board;
            else if (board.roomSize() > bestBoard.roomSize())
                bestBoard = board;

            if (bestBoard.roomSize() >= $t.$baseType.prototype.getMinRoomSize.call(this))
                break;

            var seed = $t.$baseType.prototype.getSeed.call(this);
            if (seed >= 0)
                seed++;
            else
                seed--;
            $t.$baseType.prototype.setSeed.call(this, seed);

            count++;
        }
        $t.$baseType.prototype.getLogger.call(this).DungeonGeneration$Logging$IXLogger$info("Board generation completed at attempt: " + $d.toString(count));
        $t.$baseType.prototype.setBoard.call(this, bestBoard);
        return bestBoard;
    };
});
DungeonGeneration.Generator.Pickers.CardinalPoint = $d.typeEnum("DungeonGeneration.Generator.Pickers.CardinalPoint", 45, $asm, 257, ["NORD", "EST", "SUD", "WEST"], [0, 1, 2, 3]);
$d.define(DungeonGeneration.Generator.Pickers.CardinalPointPicker, null, function($t, $p) {
    $t.$ator = function() {
        this._intRangePicker = null;
    };
    $t.ctor = function CardinalPointPicker(aStrategy) {
        $t.$baseType.ctor.call(this);
        this._intRangePicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(0, 3, aStrategy);
    };
    $p.draw = function CardinalPointPicker_draw() {
        return this._intRangePicker.draw();
    };
    $p.nextClockwise = function CardinalPointPicker_nextClockwise(aPoint) {
        var next = ((aPoint | 0) + 1) % 4;
        return next;
    };
});
$d.define(DungeonGeneration.Generator.Pickers.CellInRangePicker, null, function($t, $p) {
    $t.$ator = function() {
        this._strategy = null;
        this._min = null;
        this._max = null;
    };
    $t.ctor = function CellInRangePicker(aStrategy) {
        $t.$baseType.ctor.call(this);
        this._strategy = aStrategy;
    };
    $p.drawBetween = function CellInRangePicker_drawBetween(min, max) {
        return this.drawBetweenWithExclusion(min, max, $d.array(DungeonGeneration.Generator.Domain.Cell, 
            []));
    };
    $p.drawBetweenWithExclusion = function CellInRangePicker_drawBetweenWithExclusion(min, max, excluded) {
        if (min.hasNegativeIndexes() && max.hasNegativeIndexes())
            return min;
        if (min.hasNegativeIndexes())
            min = min.toNearestPositiveCell();
        if (max.hasNegativeIndexes())
            max = max.toNearestPositiveCell();

        var uniqueExclusion = new (System.Collections.Generic.HashSet$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        for (var $i = 0, $length = excluded.length; $i < $length; $i++) {
            var each = excluded[$i];
            var toAdd = each;
            if (each.hasNegativeIndexes())
                toAdd = toAdd.toNearestPositiveCell();
            uniqueExclusion.Add(toAdd);
        }

        var cleanedExclusions = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor$1)(uniqueExclusion);
        var distance = min.distance(max) - cleanedExclusions.get_Count();
        if (distance <= 0)
            return min;

        var selectedCellPosition = this._strategy.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween(0, 
            distance - 1);

        var cells = min.cells(max);
        var asList = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor$1)(cells);
        var $iter = cleanedExclusions;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            asList.Remove(each);
        }
        return asList.get_Item(selectedCellPosition);
    };
});
DungeonGeneration.Generator.Pickers.IPickerStrategy = $d.type("DungeonGeneration.Generator.Pickers.IPickerStrategy", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Pickers.IPickerStrategy];
    $t.$ator = function() {
        this._originalSeed = 0;
        this._currentSeed = 0;
        this._logger = null;
    };
    $t.ctor = function CustomSeededPickerStrategy(seed) {
        $t.$baseType.ctor.call(this);
        this._originalSeed = seed;
        this._currentSeed = seed;
        this._logger = new DungeonGeneration.Logging.NullLogger.ctor();
    };
    $p.setLogger = function CustomSeededPickerStrategy_setLogger(logger) {
        this._logger = logger;
    };
    $p.drawBetween = function CustomSeededPickerStrategy_drawBetween(valueA, valueB) {
        var baseNumber = System.Math.Sin(this._currentSeed) * 10000;
        var percentage = baseNumber - System.Math.Floor$1(baseNumber);
        var rangeDiff = System.Math.Abs(valueB - valueA) + 1;
        var sel = percentage * rangeDiff - 1;
        var index = (System.Math.Round$1(sel, 0) | 0);
        if (index < 0)
            index = 0;
        var result;
        if (valueA <= valueB) {
            result = valueA + index;
        }
        else {
            result = valueA - index;
        }
        if (this._originalSeed >= 0)
            this._currentSeed++;
        else
            this._currentSeed--;
        return result;
    };
    $p.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween = $p.drawBetween;
});
$d.define(DungeonGeneration.Generator.Pickers.FloatInRangePicker, null, function($t, $p) {
    $t.$ator = function() {
        this._max = 0;
        this._min = 0;
        this._pickStrategy = null;
    };
    $t.ctor = function FloatInRangePicker(min, max, pickStrategy) {
        $t.$baseType.ctor.call(this);
        this._min = min;
        this._max = max;
        this._pickStrategy = pickStrategy;
    };
    $p.draw = function FloatInRangePicker_draw() {
        var min = ((this._min * 10) | 0);
        var max = ((this._max * 10) | 0);
        var picked = this._pickStrategy.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween(min, 
            max);
        var result = picked / 10;
        return result;
    };
});
$d.define(DungeonGeneration.Generator.Pickers.IntInRangePicker, null, function($t, $p) {
    $t.$ator = function() {
        this._max = 0;
        this._min = 0;
        this._pickStrategy = null;
    };
    $t.ctor = function IntInRangePicker(min, max, pickStrategy) {
        $t.$baseType.ctor.call(this);
        this._min = min;
        this._max = max;
        this._pickStrategy = pickStrategy;
    };
    $p.draw = function IntInRangePicker_draw() {
        return this._pickStrategy.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween(this._min, 
            this._max);
    };
});
$d.define(DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Pickers.IPickerStrategy];
    $t.$ator = function() {
        this._random = null;
        this._seed = 0;
    };
    $t.ctor = function RandomSeededPickerStrategy(seed) {
        $t.$baseType.ctor.call(this);
        this._seed = seed;
        this._random = new System.Random.ctor$1(seed);
    };
    $p.drawBetween = function RandomSeededPickerStrategy_drawBetween(min, max) {
        return this._random.Next$2(min, max + 1);
    };
    $p.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween = $p.drawBetween;
});
DungeonGeneration.Generator.Plotters.IDungeonBoardPlotter = $d.type("DungeonGeneration.Generator.Plotters.IDungeonBoardPlotter", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Generator.Plotters.DetailedTilesPlotter, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Plotters.IDungeonBoardPlotter];
    $t.ctor = function DetailedTilesPlotter() {
        $t.$baseType.ctor.call(this);
    };
    $p.applyOnCorridor = function DetailedTilesPlotter_applyOnCorridor(corridor, map) {
        for (var row = 0; row < corridor.height(); row++) {
            for (var col = 0; col < corridor.width(); col++) {
                var pos = corridor.topLeftVertex().plusCell(row, col);
                var rowPos = pos.row();
                var colPos = pos.col();

                if (pos.isEqual(corridor.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 11 : 13;
                }
                else if (pos.isEqual(corridor.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 10 : 12;
                }
                else if (pos.isEqual(corridor.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 13 : 11;
                }
                else if (pos.isEqual(corridor.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 12 : 10;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.topRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 2;
                }
                else if (pos.isWithin$1(corridor.topRightVertex(), corridor.bottomRightVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 3;
                }
                else if (pos.isWithin$1(corridor.bottomLeftVertex(), corridor.bottomRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 4;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.bottomLeftVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 5;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
            }
        }

        if (corridor.isSharingBottomLeftVertexWithSourceRoom()) {
            map[corridor.bottomLeftVertex().row() * map.$ranks[1] + corridor.bottomLeftVertex().col()] = corridor.isVertical() ? 5 : 4;
        }
        if (corridor.isSharingTopRightVertexWithSourceRoom()) {
            map[corridor.topRightVertex().row() * map.$ranks[1] + corridor.topRightVertex().col()] = corridor.isVertical() ? 3 : 2;
        }
        if (corridor.isSharingTopLeftVertexWithSourceRoom()) {
            map[corridor.topLeftVertex().row() * map.$ranks[1] + corridor.topLeftVertex().col()] = corridor.isVertical() ? 5 : 2;
        }
        if (corridor.isSharingBottomRightVertexWithSourceRoom()) {
            map[corridor.bottomRightVertex().row() * map.$ranks[1] + corridor.bottomRightVertex().col()] = corridor.isVertical() ? 3 : 4;
        }

        if (corridor.isSharingBottomLeftVertexWithDestRoom()) {
            map[corridor.bottomLeftVertex().row() * map.$ranks[1] + corridor.bottomLeftVertex().col()] = corridor.isVertical() ? 5 : 4;
        }
        if (corridor.isSharingTopRightVertexWithDestRoom()) {
            map[corridor.topRightVertex().row() * map.$ranks[1] + corridor.topRightVertex().col()] = corridor.isVertical() ? 3 : 2;
        }
        if (corridor.isSharingTopLeftVertexWithDestRoom()) {
            map[corridor.topLeftVertex().row() * map.$ranks[1] + corridor.topLeftVertex().col()] = corridor.isVertical() ? 5 : 2;
        }
        if (corridor.isSharingBottomRightVertexWithDestRoom()) {
            map[corridor.bottomRightVertex().row() * map.$ranks[1] + corridor.bottomRightVertex().col()] = corridor.isVertical() ? 3 : 4;
        }
    };
    $p.applyOnRoom = function DetailedTilesPlotter_applyOnRoom(room, map) {
        for (var row = 0; row < room.height(); row++) {
            for (var col = 0; col < room.width(); col++) {
                var pos = room.topLeftVertex().plusCell(row, col);
                var rowPos = pos.row();
                var colPos = pos.col();

                if (pos.isEqual(room.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
                else if (pos.isEqual(room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
                else if (pos.isEqual(room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
                else if (pos.isEqual(room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 2;
                }
                else if (pos.isWithin$1(room.topRightVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 3;
                }
                else if (pos.isWithin$1(room.bottomLeftVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 4;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 5;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
            }
        }

        this.joinWithCorridors(room, map);
    };
    $p.joinWithCorridors = function DetailedTilesPlotter_joinWithCorridors(room, map) {
        var xPosC;
        var yPosC;

        if (!room.hasCorridorSharingVertex(room.topLeftVertex())) {
            xPosC = room.topLeftVertex().row();
            yPosC = room.topLeftVertex().col();
            map[xPosC * map.$ranks[1] + yPosC] = 6;
            map[xPosC * map.$ranks[1] + (yPosC + 1)] = 0;
            map[(xPosC + 1) * map.$ranks[1] + yPosC] = 0;
        }

        if (!room.hasCorridorSharingVertex(room.topRightVertex())) {
            xPosC = room.topRightVertex().row();
            yPosC = room.topRightVertex().col();
            map[xPosC * map.$ranks[1] + yPosC] = 7;
            map[xPosC * map.$ranks[1] + (yPosC - 1)] = 0;
            map[(xPosC + 1) * map.$ranks[1] + yPosC] = 0;
        }

        if (!room.hasCorridorSharingVertex(room.bottomRightVertex())) {
            xPosC = room.bottomRightVertex().row();
            yPosC = room.bottomRightVertex().col();
            map[xPosC * map.$ranks[1] + yPosC] = 8;
            map[xPosC * map.$ranks[1] + (yPosC - 1)] = 0;
            map[(xPosC - 1) * map.$ranks[1] + yPosC] = 0;
        }

        if (!room.hasCorridorSharingVertex(room.bottomLeftVertex())) {
            xPosC = room.bottomLeftVertex().row();
            yPosC = room.bottomLeftVertex().col();
            map[xPosC * map.$ranks[1] + yPosC] = 9;
            map[xPosC * map.$ranks[1] + (yPosC + 1)] = 0;
            map[(xPosC - 1) * map.$ranks[1] + yPosC] = 0;
        }
    };
    $p.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnRoom = $p.applyOnRoom;
    $p.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnCorridor = $p.applyOnCorridor;
});
DungeonGeneration.Generator.Plotters.DetailedTileType = $d.typeEnum("DungeonGeneration.Generator.Plotters.DetailedTileType", 45, $asm, 257, ["Empty", "Floor", "Wall_N", "Wall_E", "Wall_S", "Wall_W", "Corner_INN_NW", "Corner_INN_NE", "Corner_INN_SE", "Corner_INN_SW", "Corner_OUT_NE", "Corner_OUT_NW", "Corner_OUT_SW", "Corner_OUT_SE"], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
$d.define(DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Plotters.IDungeonBoardPlotter];
    $t.ctor = function ZeroOneTilesPlotter() {
        $t.$baseType.ctor.call(this);
    };
    $p.applyOnCorridor = function ZeroOneTilesPlotter_applyOnCorridor(corridor, map) {
        for (var row = 0; row < corridor.height(); row++) {
            for (var col = 0; col < corridor.width(); col++) {
                var pos = corridor.topLeftVertex().plusCell(row, col);
                var rowPos = pos.row();
                var colPos = pos.col();

                if (pos.isEqual(corridor.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(corridor.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(corridor.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(corridor.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.topRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(corridor.topRightVertex(), corridor.bottomRightVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(corridor.bottomLeftVertex(), corridor.bottomRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.bottomLeftVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
            }
        }
    };
    $p.applyOnRoom = function ZeroOneTilesPlotter_applyOnRoom(room, map) {
        for (var row = 0; row < room.height(); row++) {
            for (var col = 0; col < room.width(); col++) {
                var pos = room.topLeftVertex().plusCell(row, col);
                var rowPos = pos.row();
                var colPos = pos.col();

                if (pos.isEqual(room.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isEqual(room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(room.topRightVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(room.bottomLeftVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 0;
                }
            }
        }
    };
    $p.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnRoom = $p.applyOnRoom;
    $p.DungeonGeneration$Generator$Plotters$IDungeonBoardPlotter$applyOnCorridor = $p.applyOnCorridor;
});
DungeonGeneration.Generator.Plotters.ZeroOneTileType = $d.typeEnum("DungeonGeneration.Generator.Plotters.ZeroOneTileType", 45, $asm, 257, ["Empty", "Wall"], [0, 1]);
DungeonGeneration.Logging.IXLogger = $d.type("DungeonGeneration.Logging.IXLogger", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Logging.ConsoleLogger, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Logging.IXLogger];
    $t.ctor = function ConsoleLogger() {
        $t.$baseType.ctor.call(this);
    };
    $p.error = function ConsoleLogger_error(v) {
        System.Console.WriteLine$10("[ERRO]: " + v);
    };
    $p.info = function ConsoleLogger_info(v) {
        System.Console.WriteLine$10("[INFO]: " + v);
    };
    $p.warning = function ConsoleLogger_warning(v) {
        System.Console.WriteLine$10("[WARN]: " + v);
    };
    $p.DungeonGeneration$Logging$IXLogger$warning = $p.warning;
    $p.DungeonGeneration$Logging$IXLogger$error = $p.error;
    $p.DungeonGeneration$Logging$IXLogger$info = $p.info;
});
$d.define(DungeonGeneration.Logging.NullLogger, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Logging.IXLogger];
    $t.ctor = function NullLogger() {
        $t.$baseType.ctor.call(this);
    };
    $p.error = function NullLogger_error(v) {
    };
    $p.info = function NullLogger_info(v) {
    };
    $p.warning = function NullLogger_warning(v) {
    };
    $p.DungeonGeneration$Logging$IXLogger$warning = $p.warning;
    $p.DungeonGeneration$Logging$IXLogger$error = $p.error;
    $p.DungeonGeneration$Logging$IXLogger$info = $p.info;
});
$d.define(Forest012Plotter, null, function($t, $p) {
    $t.$intfs = function() { return [ICaveBoardPlotter$1($d.arrayType(System.Int32, 2))]; };
    $t.$ator = function() {
        this._grid = null;
        this._treeTickness = 0;
    };
    $t.ctor = function Forest012Plotter() {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
        this._treeTickness = 1;
    };
    $t.ctor$1 = function Forest012Plotter(treeTickness) {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
        this._treeTickness = treeTickness;
    };
    $p.applyOn = function Forest012Plotter_applyOn(board) {
        this._grid = new OIGrid.ctor$1(board.rows(), board.cols());

        var populated = new OIGrid.ctor$1(board.rows(), board.cols());
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++)
            (function() {
                var eachShape = $a[$i];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);
        for (var $i1 = 0, $a1 = board.corridors(), $length1 = $a1.length; $i1 < $length1; $i1++)
            (function() {
                var eachShape = $a1[$i1];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);
        var inverted = populated.invert();
        inverted.forEach2($d.delegate(function(row, col, value) {
            if (value == 1 && inverted.existsCellNeighborValue(row, col, 0)) {
                this._grid.setCellValue(row, col, 3);
            }
            else {
                this._grid.setCellValue(row, col, 1);
            }
        }, this));
        populated.forEach2($d.delegate(function(row, col, value) {
            if (value == 1 && this._grid.hasCellValue(row, col, 1)) {
                this._grid.setCellValue(row, col, 0);
            }
            else if (value == 0 && this._grid.hasCellValue(row, col, 3)) {
                this._grid.setCellValue(row, col, 1);
            }
            else {
                this._grid.setCellValue(row, col, 2);
            }
        }, this));

        var edgeSize = this._treeTickness;
        for (var i = 1; i < edgeSize; i++)
            (function() {
                var cloned = this._grid.clone();
                cloned.forEach2($d.delegate(function(row, col, value) {
                    if (value == 2 && cloned.existsCellNeighborValue(row, col, 1)) {
                        this._grid.setCellValue(row, col, 1);
                    }
                }, this));
            }).call(this);
    };
    $p.result = function Forest012Plotter_result() {
        return this._grid.asMatrix();
    };
    $p.ICaveBoardPlotter$1$applyOn = $p.applyOn;
    $p.ICaveBoardPlotter$1$result = $p.result;
});
$d.define(Forest01Plotter, null, function($t, $p) {
    $t.$intfs = function() { return [ICaveBoardPlotter$1($d.arrayType(System.Int32, 2))]; };
    $t.$ator = function() {
        this._grid = null;
        this._treeTickness = 0;
    };
    $t.ctor = function Forest01Plotter() {
        $t.$baseType.ctor.call(this);
        this._grid = new OIGrid.ctor$1(0, 0);
        this._treeTickness = 1;
    };
    $p.applyOn = function Forest01Plotter_applyOn(board) {
        this._grid = new OIGrid.ctor$1(board.rows(), board.cols());

        var populated = new OIGrid.ctor$1(board.rows(), board.cols());
        for (var $i = 0, $a = board.rooms(), $length = $a.length; $i < $length; $i++)
            (function() {
                var eachShape = $a[$i];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);
        for (var $i1 = 0, $a1 = board.corridors(), $length1 = $a1.length; $i1 < $length1; $i1++)
            (function() {
                var eachShape = $a1[$i1];
                eachShape.IXShape$forEachCellAbs($d.delegate(function(row, col, value) {
                    populated.setCellValue(row, col, value);
                }, this));
            }).call(this);
        var inverted = populated.invert();
        inverted.forEach2($d.delegate(function(row, col, value) {
            if (value == 1 && inverted.existsCellNeighborValue(row, col, 0)) {
                this._grid.setCellValue(row, col, 3);
            }
            else {
                this._grid.setCellValue(row, col, 1);
            }
        }, this));
        populated.forEach2($d.delegate(function(row, col, value) {
            if (value == 1 && this._grid.hasCellValue(row, col, 1)) {
                this._grid.setCellValue(row, col, 0);
            }
            else if (value == 0 && this._grid.hasCellValue(row, col, 3)) {
                this._grid.setCellValue(row, col, 1);
            }
            else {
                this._grid.setCellValue(row, col, 2);
            }
        }, this));

        var edgeSize = this._treeTickness;
        for (var i = 1; i < edgeSize; i++)
            (function() {
                var cloned = this._grid.clone();
                cloned.forEach2($d.delegate(function(row, col, value) {
                    if (value == 2 && cloned.existsCellNeighborValue(row, col, 1)) {
                        this._grid.setCellValue(row, col, 1);
                    }
                }, this));
            }).call(this);

        this._grid.forEach2($d.delegate(function(row, col, value) {
            if (value == 2)
                this._grid.setCellValue(row, col, 0);
        }, this));
    };
    $p.result = function Forest01Plotter_result() {
        return this._grid.asMatrix();
    };
    $p.ICaveBoardPlotter$1$applyOn = $p.applyOn;
    $p.ICaveBoardPlotter$1$result = $p.result;
});
$d.define(ForestGenUtil, null, function($t, $p) {
    $t.ctor = function ForestGenUtil() {
        $t.$baseType.ctor.call(this);
    };
    $t.createServerGen = function ForestGenUtil_createServerGen() {
        var gen = new CaveGeneration.Generator.CaveGenerator.ctor();
        gen.setPlotter(new Forest01Plotter.ctor());
        return gen;
    };
    $t.createServerGenWithLog = function ForestGenUtil_createServerGenWithLog() {
        var gen = $t.createServerGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.createClientGen = function ForestGenUtil_createClientGen() {
        var gen = new CaveGeneration.Generator.CaveGenerator.ctor();
        gen.setPlotter(new Forest012Plotter.ctor());
        return gen;
    };
    $t.createClientGenWithLog = function ForestGenUtil_createClientGenWithLog() {
        var gen = $t.createClientGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.printMatrix = function ForestGenUtil_printMatrix(matrix) {
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1)
                    result += " ";
            }
            if (i != rows - 1)
                result += "\n";
        }
        System.Console.WriteLine$10(result);
    };
    $t.boardAsMatrix = function ForestGenUtil_boardAsMatrix(board) {
        var plotter = new Forest01Plotter.ctor();
        plotter.applyOn(board);
        return plotter.result();
    };
    $t.printBoard = function ForestGenUtil_printBoard(board) {
        var plotter = new Forest01Plotter.ctor();
        plotter.applyOn(board);
        $t.printMatrix(plotter.result());
    };
    $t.printForTest = function ForestGenUtil_printForTest(board) {
        var plotter = new Forest01Plotter.ctor();
        plotter.applyOn(board);
        $t.printMatrixWithIndexes(plotter.result());

        System.Console.WriteLine$10("var board = new _CaveBoard(" + $d.toString(board.rows()) + ", " + $d.toString(board.cols()) + ");");

        var currName = null;
        var prevName = null;
        for (var i = 0; i < board.all().length; i++) {
            var current = board.all()[i];
            prevName = currName;
            if (i % 2 == 0) {
                var roomIndex = (i / 2 | 0) + 1;
                currName = "room" + $d.toString(roomIndex);
                current.IXShape$accept(new ForestGenUtil.PrepareForTestShapeVisitor.ctor(currName));
                System.Console.WriteLine$10("board.addRoom(" + currName + ");");
            }
            else {
                currName = "corr" + $d.toString(i) + "" + $d.toString((i + 1));
                current.IXShape$accept(new ForestGenUtil.PrepareForTestShapeVisitor.ctor(currName));
                System.Console.WriteLine$10("board.addCorridor(" + currName + ");");
            }
        }
    };
    $t.printMatrixWithIndexes = function ForestGenUtil_printMatrixWithIndexes(matrix) {
        var showIndexes = true;
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        if (showIndexes) {
            result += "\n";
            for (var n = 0; n < cols; n++) {
                if (n == 0)
                    result += "     ";
                result += $d.toString(n) + ",";
                if (n < 9)
                    result += " ";
            }
        }
        result += "\n";
        for (var i = 0; i < rows; i++) {
            if (showIndexes && i < 10)
                result += " " + $d.toString(i) + " ";
            if (showIndexes && i >= 10)
                result += $d.toString(i) + " ";

            for (var j = 0; j < cols; j++) {
                if (j == 0)
                    result += " {";
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1)
                    result += ", ";
            }
            result += "}";
            if (showIndexes)
                result += " " + $d.toString(i);
            if (i != rows - 1)
                result += ",\n";
        }
        if (showIndexes) {
            result += "\n";
            for (var m = 0; m < cols; m++) {
                if (m == 0)
                    result += "     ";
                result += $d.toString(m) + ",";
                if (m < 9)
                    result += " ";
            }
        }
        System.Console.WriteLine$10(result);
    };
    $t.printArray = function ForestGenUtil_printArray(list) {
        var size = list.GetLength(0);

        var result = "[" + $d.toString(size) + "] ";

        for (var i = 0; i < size; i++) {
            if (i == 0)
                result += " {";
            result += list[i].toString();
            if (i != size - 1)
                result += ", ";
        }
        result += "}";
        System.Console.WriteLine$10(result);
    };
});
$d.define(ForestGenUtil.PrepareForTestShapeVisitor, AShapeVisitor, function($t, $p) {
    $t.$intfs = [IShapeVisitor];
    $t.$ator = function() {
        this._varName = null;
    };
    $t.ctor = function PrepareForTestShapeVisitor(varName) {
        $t.$baseType.ctor.call(this);
        this._varName = varName;
    };
    $p._visit$1 = function PrepareForTestShapeVisitor__visit(aShape) {
        this.printInstance(aShape, "ElliShape");
        this.printSetMethod(aShape);
    };
    $p._visit$4 = function PrepareForTestShapeVisitor__visit(aShape) {
        this.printInstance(aShape, "RectShape");
        this.printSetMethod(aShape);
    };
    $p._visit$2 = function PrepareForTestShapeVisitor__visit(aShape) {
        System.Console.WriteLine$10("var " + this._varName + " = new FreeShape();");
        this.printSetMethod(aShape);
    };
    $p.printInstance = function PrepareForTestShapeVisitor_printInstance(aShape, className) {
        var row = aShape.topLeftVertex().row();
        var col = aShape.topLeftVertex().col();
        var rows = aShape.grid().rows();
        var cols = aShape.grid().columns();
        System.Console.WriteLine$10("var " + this._varName + " = new " + className + "(new _Cell(" + $d.toString(row) + ", " + $d.toString(col) + "), new _OIGrid(" + $d.toString(rows) + ", " + $d.toString(cols) + "));");
    };
    $p.printSetMethod = function PrepareForTestShapeVisitor_printSetMethod(aShape) {
        aShape.IXShape$forEachCell2($d.delegate(function(row, col, value) {
            if (value == 1) {
                var result = this._varName + ".setCellValue(" + $d.toString(row) + ", " + $d.toString(col) + ", 1);";
                System.Console.WriteLine$10(result);
            }
        }, this));
    };
});
$d.define(CaveGenUtil, null, function($t, $p) {
    $t.ctor = function CaveGenUtil() {
        $t.$baseType.ctor.call(this);
    };
    $t.createServerGen = function CaveGenUtil_createServerGen() {
        var gen = new CaveGeneration.Generator.CaveGenerator.ctor();
        gen.setPlotter(new ZeroOneCavePlotter.ctor());
        return gen;
    };
    $t.createServerGen2 = function CaveGenUtil_createServerGen2() {
        var gen = new CaveGeneration.Generator.CaveGenerator.ctor();
        gen.setPlotter(new ZeroOneTwoFillerCavePlotter.ctor());
        return gen;
    };
    $t.createServerGenWithLog = function CaveGenUtil_createServerGenWithLog() {
        var gen = $t.createServerGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.createClientGen = function CaveGenUtil_createClientGen() {
        var gen = new CaveGeneration.Generator.CaveGenerator.ctor();
        gen.setPlotter(new ZeroOneFillerCavePlotter.ctor());
        return gen;
    };
    $t.createClientGenWithLog = function CaveGenUtil_createClientGenWithLog() {
        var gen = $t.createClientGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.printMatrix = function CaveGenUtil_printMatrix(matrix) {
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1)
                    result += " ";
            }
            if (i != rows - 1)
                result += "\n";
        }
        System.Console.WriteLine$10(result);
    };
    $t.boardAsMatrix = function CaveGenUtil_boardAsMatrix(board) {
        var plotter = new ZeroOneFillerCavePlotter.ctor();
        plotter.applyOn(board);
        return plotter.result();
    };
    $t.boardAsMatrix2 = function CaveGenUtil_boardAsMatrix2(board) {
        var plotter = new ZeroOneTwoFillerCavePlotter.ctor();
        plotter.applyOn(board);
        return plotter.result();
    };
    $t.printBoard = function CaveGenUtil_printBoard(board) {
        var plotter = new ZeroOneFillerCavePlotter.ctor();
        plotter.applyOn(board);
        $t.printMatrix(plotter.result());
    };
    $t.printForTest = function CaveGenUtil_printForTest(board) {
        var plotter = new ZeroOneTwoFillerCavePlotter.ctor();
        plotter.applyOn(board);
        $t.printMatrixWithIndexes(plotter.result());

        System.Console.WriteLine$10("var board = new _CaveBoard(" + $d.toString(board.rows()) + ", " + $d.toString(board.cols()) + ");");

        var currName = null;
        var prevName = null;
        for (var i = 0; i < board.all().length; i++) {
            var current = board.all()[i];
            prevName = currName;
            if (i % 2 == 0) {
                var roomIndex = (i / 2 | 0) + 1;
                currName = "room" + $d.toString(roomIndex);
                current.IXShape$accept(new CaveGenUtil.PrepareForTestShapeVisitor.ctor(currName));
                System.Console.WriteLine$10("board.addRoom(" + currName + ");");
            }
            else {
                currName = "corr" + $d.toString(i) + "" + $d.toString((i + 1));
                current.IXShape$accept(new CaveGenUtil.PrepareForTestShapeVisitor.ctor(currName));
                System.Console.WriteLine$10("board.addCorridor(" + currName + ");");
            }
        }
    };
    $t.printMatrixWithIndexes = function CaveGenUtil_printMatrixWithIndexes(matrix) {
        var showIndexes = true;
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        if (showIndexes) {
            result += "\n";
            for (var n = 0; n < cols; n++) {
                if (n == 0)
                    result += "     ";
                result += $d.toString(n) + ",";
                if (n < 9)
                    result += " ";
            }
        }
        result += "\n";
        for (var i = 0; i < rows; i++) {
            if (showIndexes && i < 10)
                result += " " + $d.toString(i) + " ";
            if (showIndexes && i >= 10)
                result += $d.toString(i) + " ";

            for (var j = 0; j < cols; j++) {
                if (j == 0)
                    result += " {";
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1)
                    result += ", ";
            }
            result += "}";
            if (showIndexes)
                result += " " + $d.toString(i);
            if (i != rows - 1)
                result += ",\n";
        }
        if (showIndexes) {
            result += "\n";
            for (var m = 0; m < cols; m++) {
                if (m == 0)
                    result += "     ";
                result += $d.toString(m) + ",";
                if (m < 9)
                    result += " ";
            }
        }
        System.Console.WriteLine$10(result);
    };
    $t.printArray = function CaveGenUtil_printArray(list) {
        var size = list.GetLength(0);

        var result = "[" + $d.toString(size) + "] ";

        for (var i = 0; i < size; i++) {
            if (i == 0)
                result += " {";
            result += list[i].toString();
            if (i != size - 1)
                result += ", ";
        }
        result += "}";
        System.Console.WriteLine$10(result);
    };
    $t.newBoard = function CaveGenUtil_newBoard(rowSize, colSize) {
        return new CaveBoard.ctor(new OIGrid.ctor$1(rowSize, colSize));
    };
    $t.newRoom = function CaveGenUtil_newRoom(topLeftVertexRow, topLeftVertexCol, rowSize, colSize) {
        var filler = new ShapeCellularAutomaton.ctor(48, 60, 5);
        var result = new RectShape.ctor(new DungeonGeneration.Generator.Domain.Cell.ctor(topLeftVertexRow, 
            topLeftVertexCol), new OIGrid.ctor$1(rowSize, colSize));
        filler.applyOn(result);
        result.deleteRegionsButTheBiggest();
        return result;
    };
    $t.newCorridor = function CaveGenUtil_newCorridor(fromRoom, toRoom, width) {
        return CaveCorridorFactory.createCorrShape(fromRoom, toRoom, width);
    };
});
$d.define(CaveGenUtil.PrepareForTestShapeVisitor, AShapeVisitor, function($t, $p) {
    $t.$intfs = [IShapeVisitor];
    $t.$ator = function() {
        this._varName = null;
    };
    $t.ctor = function PrepareForTestShapeVisitor(varName) {
        $t.$baseType.ctor.call(this);
        this._varName = varName;
    };
    $p._visit$1 = function PrepareForTestShapeVisitor__visit(aShape) {
        this.printInstance(aShape, "ElliShape");
        this.printSetMethod(aShape);
    };
    $p._visit$4 = function PrepareForTestShapeVisitor__visit(aShape) {
        this.printInstance(aShape, "RectShape");
        this.printSetMethod(aShape);
    };
    $p._visit$2 = function PrepareForTestShapeVisitor__visit(aShape) {
        System.Console.WriteLine$10("var " + this._varName + " = new FreeShape();");
        this.printSetMethod(aShape);
    };
    $p.printInstance = function PrepareForTestShapeVisitor_printInstance(aShape, className) {
        var row = aShape.topLeftVertex().row();
        var col = aShape.topLeftVertex().col();
        var rows = aShape.grid().rows();
        var cols = aShape.grid().columns();
        System.Console.WriteLine$10("var " + this._varName + " = new " + className + "(new _Cell(" + $d.toString(row) + ", " + $d.toString(col) + "), new _OIGrid(" + $d.toString(rows) + ", " + $d.toString(cols) + "));");
    };
    $p.printSetMethod = function PrepareForTestShapeVisitor_printSetMethod(aShape) {
        aShape.IXShape$forEachCell2($d.delegate(function(row, col, value) {
            if (value == 1) {
                var result = this._varName + ".setCellValue(" + $d.toString(row) + ", " + $d.toString(col) + ", 1);";
                System.Console.WriteLine$10(result);
            }
        }, this));
    };
});
$d.define(DunGenUtil, null, function($t, $p) {
    $t.ctor = function DunGenUtil() {
        $t.$baseType.ctor.call(this);
    };
    $t.createServerGen = function DunGenUtil_createServerGen() {
        var gen = new DungeonGeneration.Generator.DungeonGenerator.ctor();
        gen.setPlotter(new DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter.ctor());
        return gen;
    };
    $t.createServerGenWithLog = function DunGenUtil_createServerGenWithLog() {
        var gen = $t.createServerGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.createClientGen = function DunGenUtil_createClientGen() {
        var gen = new DungeonGeneration.Generator.DungeonGenerator.ctor();
        gen.setPlotter(new DungeonGeneration.Generator.Plotters.DetailedTilesPlotter.ctor());
        return gen;
    };
    $t.createClientGenWithLog = function DunGenUtil_createClientGenWithLog() {
        var gen = $t.createClientGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.printMatrix = function DunGenUtil_printMatrix(matrix) {
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                if (j == 0)
                    result += " {";
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1)
                    result += ", ";
            }
            result += "}";
            if (i != rows - 1)
                result += ",\n";
        }
        System.Console.WriteLine$10(result);
    };
    $t.newBoard = function DunGenUtil_newBoard(rowSize, colSize) {
        return new DungeonGeneration.Generator.Domain.Board.ctor(new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, 
            colSize));
    };
    $t.newRoom = function DunGenUtil_newRoom(topLeftVertexRow, topLeftVertexCol, rowSize, colSize) {
        return new Room.ctor(new DungeonGeneration.Generator.Domain.Cell.ctor(topLeftVertexRow, topLeftVertexCol), 
            new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, colSize));
    };
    $t.newCorridor = function DunGenUtil_newCorridor(topLeftVertexRow, topLeftVertexCol, rowSize, colSize, orientation) {
        var versus = orientation.Equals$1("horizontal") ? 0 : 1;
        return new Corridor.ctor(new DungeonGeneration.Generator.Domain.Cell.ctor(topLeftVertexRow, topLeftVertexCol), 
            new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, colSize), versus);
    };
});
return $asm;
})();
//# sourceMappingURL=dungen.js.map
