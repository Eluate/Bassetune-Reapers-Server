/*!
* DunGenJs, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
*
* Generated by DuoCode Compiler 2.2.1631.0 [Trial]
*/
var mscorlib = require("./mscorlib");
module.exports = (function DunGenJs(mscorlib) {
"use strict";
var $asm = {
    fullName: "DunGenJs",
    anonymousTypes: [],
    types: [],
    getAttrs: function() { return [new System.Reflection.AssemblyTitleAttribute.ctor("DunGenJs"), new System.Reflection.AssemblyDescriptionAttribute.ctor(""), new System.Reflection.AssemblyConfigurationAttribute.ctor(""), new System.Reflection.AssemblyCompanyAttribute.ctor("BNP Paribas"), new System.Reflection.AssemblyProductAttribute.ctor("DunGenJs"), new System.Reflection.AssemblyCopyrightAttribute.ctor("Copyright \xA9 BNP Paribas 2017"), new System.Reflection.AssemblyTrademarkAttribute.ctor(""), new System.Reflection.AssemblyCultureAttribute.ctor(""), new System.Reflection.AssemblyVersionAttribute.ctor("1.0.0.0"), new System.Reflection.AssemblyFileVersionAttribute.ctor("1.0.0.0"), new DuoCode.Runtime.CompilerAttribute.ctor("2.2.1631.0")]; }
};
var $g = (typeof(global) !== "undefined" ? global : (typeof(window) !== "undefined" ? window : self));
var DungeonGeneration = $g.DungeonGeneration = $g.DungeonGeneration || {};
DungeonGeneration.Generator = DungeonGeneration.Generator || {};
DungeonGeneration.Generator.Domain = DungeonGeneration.Generator.Domain || {};
DungeonGeneration.Generator.Pickers = DungeonGeneration.Generator.Pickers || {};
DungeonGeneration.Generator.Plotters = DungeonGeneration.Generator.Plotters || {};
DungeonGeneration.Logging = DungeonGeneration.Logging || {};
var $d = DuoCode.Runtime;
$d.$assemblies["DunGenJs"] = $asm;
var DunGenUtil = $g.DunGenUtil = $d.declare("DunGenUtil", 0, $asm);
DungeonGeneration.Generator.Domain.Board = $d.declare("DungeonGeneration.Generator.Domain.Board", 0, 
    $asm);
DungeonGeneration.Generator.Domain.Cell = $d.declare("DungeonGeneration.Generator.Domain.Cell", 0, $asm);
var Corridor = $g.Corridor = $d.declare("Corridor", 0, $asm);
DungeonGeneration.Generator.Domain.Grid = $d.declare("DungeonGeneration.Generator.Domain.Grid", 0, $asm);
var Room = $g.Room = $d.declare("Room", 0, $asm);
DungeonGeneration.Generator.Pickers.CardinalPointPicker = $d.declare("DungeonGeneration.Generator.Pickers.CardinalPointPicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.CellInRangePicker = $d.declare("DungeonGeneration.Generator.Pickers.CellInRangePicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy = $d.declare("DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy", 
    0, $asm);
DungeonGeneration.Generator.Pickers.IntInRangePicker = $d.declare("DungeonGeneration.Generator.Pickers.IntInRangePicker", 
    0, $asm);
DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy = $d.declare("DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy", 
    0, $asm);
DungeonGeneration.Generator.Plotters.DetailedTilesPlotter = $d.declare("DungeonGeneration.Generator.Plotters.DetailedTilesPlotter", 
    0, $asm);
DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter = $d.declare("DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter", 
    0, $asm);
DungeonGeneration.Generator.TilesMapGenerator = $d.declare("DungeonGeneration.Generator.TilesMapGenerator", 
    0, $asm);
DungeonGeneration.Logging.ConsoleLogger = $d.declare("DungeonGeneration.Logging.ConsoleLogger", 0, $asm);
DungeonGeneration.Logging.NullLogger = $d.declare("DungeonGeneration.Logging.NullLogger", 0, $asm);
$d.define(DunGenUtil, null, function($t, $p) {
    $t.ctor = function DunGenUtil() {
        $t.$baseType.ctor.call(this);
    };
    $t.createServerGen = function DunGenUtil_createServerGen() {
        var gen = new DungeonGeneration.Generator.TilesMapGenerator.ctor();
        gen.setPlotter(new DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter.ctor());
        return gen;
    };
    $t.createServerGenWithLog = function DunGenUtil_createServerGenWithLog() {
        var gen = $t.createServerGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.createClientGen = function DunGenUtil_createClientGen() {
        var gen = new DungeonGeneration.Generator.TilesMapGenerator.ctor();
        gen.setPlotter(new DungeonGeneration.Generator.Plotters.DetailedTilesPlotter.ctor());
        return gen;
    };
    $t.createClientGenWithLog = function DunGenUtil_createClientGenWithLog() {
        var gen = $t.createClientGen();
        gen.setLogger(new DungeonGeneration.Logging.ConsoleLogger.ctor());
        return gen;
    };
    $t.printMatrix = function DunGenUtil_printMatrix(matrix) {
        var rows = matrix.GetLength(0);
        var cols = matrix.GetLength(1);

        var result = $d.toString(rows) + " x " + $d.toString(cols) + "\n";
        //Console.WriteLine(rows + " x " + cols);
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                if (j == 0) //Console.Write(" {");
                    result += " {";
                //Console.Write(matrix[i, j]);
                result += $d.toString(matrix[i * matrix.$ranks[1] + j]);
                if (j != cols - 1) //Console.Write(", "); 
                    result += ", ";
            }
            //Console.Write("}");
            result += "}";
            if (i != rows - 1) //Console.WriteLine(",");
                result += ",\n";
        }
        System.Console.WriteLine$10(result);
    };
    $t.newBoard = function DunGenUtil_newBoard(rowSize, colSize) {
        return new DungeonGeneration.Generator.Domain.Board.ctor(new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, 
            colSize));
    };
    $t.newRoom = function DunGenUtil_newRoom(topLeftVertexRow, topLeftVertexCol, rowSize, colSize) {
        return new Room.ctor(new DungeonGeneration.Generator.Domain.Cell.ctor(topLeftVertexRow, topLeftVertexCol), 
            new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, colSize));
    };
    $t.newCorridor = function DunGenUtil_newCorridor(topLeftVertexRow, topLeftVertexCol, rowSize, colSize, orientation) {
        var versus = orientation.Equals$1("horizontal") ? 0 /* Orientation.horizontal */ : 1 /* Orientation.vertical */;
        return new Corridor.ctor(new DungeonGeneration.Generator.Domain.Cell.ctor(topLeftVertexRow, topLeftVertexCol), 
            new DungeonGeneration.Generator.Domain.Grid.ctor(rowSize, colSize), versus);
    };
});
$d.define(DungeonGeneration.Generator.Domain.Board, null, function($t, $p) {
    $t.$ator = function() {
        this._grid = null;
        this._roomsAndCorridors = null;
    };
    $t.ctor$1 = function Board(rows, columns) {
        $t.ctor.call(this, new DungeonGeneration.Generator.Domain.Grid.ctor(rows, columns));
    };
    $t.ctor = function Board(mapGrid) {
        $t.$baseType.ctor.call(this);
        this._grid = mapGrid;
        this._roomsAndCorridors = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.IShape, 
            54824).ctor)();
    };
    $p.fitsIn = function Board_fitsIn(aSquare) {
        if (!aSquare.DungeonGeneration$Generator$Domain$IShape$isWithin(this._grid))
            return false;
        //Evito di controllare la collisione con l'ultimo, poiche' e' necessaria
        for (var i = 0; i < this._roomsAndCorridors.get_Count() - 1; i++) {
            var each = this._roomsAndCorridors.get_Item(i);
            if (aSquare.DungeonGeneration$Generator$Domain$IShape$collidesWith(each))
                return false;
        }
        return true;
    };
    $p.addRoom = function Board_addRoom(aRoom) {
        if (this._roomsAndCorridors.get_Count() != 0) {
            var corr = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1), 
                Corridor);
            corr.setDestinationRoom(aRoom);
            aRoom.setCorridorIncoming(corr);
        }
        this._roomsAndCorridors.Add(aRoom);
    };
    $p.asTilesMatrix = function Board_asTilesMatrix(plotter) {
        var result = this._grid.toIntMatrix();

        if (this._roomsAndCorridors.get_Count() > 0) {
            this._roomsAndCorridors.get_Item(0).DungeonGeneration$Generator$Domain$IShape$plotOn(result, 
                plotter);
        }
        return result;
    };
    $p.addCorridor = function Board_addCorridor(corr) {
        if (this._roomsAndCorridors.get_Count() != 0) {
            var room = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1), 
                Room);
            room.setCorridorOutcoming(corr);
            corr.setSourceRoom(room);
        }
        this._roomsAndCorridors.Add(corr);
    };
    $p.removeLast = function Board_removeLast() {
        if (this._roomsAndCorridors.get_Count() == 0)
            return;

        var last = this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 1);
        var beforeLast = null;
        if (this._roomsAndCorridors.get_Count() >= 2) {
            beforeLast = this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 2);
        }

        if ($d.is(last, Room)) {
            var room = $d.cast(last, Room);
            room.setCorridorIncoming(null);
            if (beforeLast != null) {
                var corr = $d.cast(beforeLast, Corridor);
                corr.setDestinationRoom(null);
            }
        }
        else {
            var corr = $d.cast(last, Corridor);
            corr.setSourceRoom(null);
            if (beforeLast != null) {
                var room = $d.cast(this._roomsAndCorridors.get_Item(this._roomsAndCorridors.get_Count() - 2), 
                    Room);
                room.setCorridorOutcoming(null);
            }
        }
        this._roomsAndCorridors.RemoveAt(this._roomsAndCorridors.get_Count() - 1);
    };
    $p.numberOfRoomsAndCorridors = function Board_numberOfRoomsAndCorridors() {
        return this._roomsAndCorridors.get_Count();
    };
    $p.rooms = function Board_rooms() {
        var result = new (System.Collections.Generic.List$1(Room, 41451).ctor)();
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Room))
                result.Add($d.cast(each, Room));
        }
        return result.ToArray();
    };
    $p.corridors = function Board_corridors() {
        var result = new (System.Collections.Generic.List$1(Corridor, 53384).ctor)();
        var $iter = this._roomsAndCorridors;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            if ($d.is(each, Corridor))
                result.Add($d.cast(each, Corridor));
        }
        return result.ToArray();
    };
});
$d.define(DungeonGeneration.Generator.Domain.Cell, null, function($t, $p) {
    $t.$ator = function() {
        this._row = 0;
        this._col = 0;
    };
    $t.ctor = function Cell(aRow, aCol) {
        $t.$baseType.ctor.call(this);
        this._row = aRow;
        this._col = aCol;
    };
    $p.Equals = function Cell_Equals(obj) {
        return this.isEqual($d.cast(obj, DungeonGeneration.Generator.Domain.Cell));
    };
    $p.ToString = function Cell_ToString() {
        return "Cell: [" + $d.toString(this._row) + ", " + $d.toString(this._col) + "]";
    };
    $p.GetHashCode = function Cell_GetHashCode() {
        return this.toString().GetHashCode();
    };
    $p.hasNegativeIndexes = function Cell_hasNegativeIndexes() {
        if (this._row < 0)
            return true;
        if (this._col < 0)
            return true;
        return false;
    };
    $p.toNearestPositiveCell = function Cell_toNearestPositiveCell() {
        var row = this._row < 0 ? 0 : this._row;
        var col = this._col < 0 ? 0 : this._col;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(row, col);
    };
    $p.distance = function Cell_distance(other) {
        var rowDistance = System.Math.Abs(this._row - other._row) + 1;

        var colDistance = System.Math.Abs(this._col - other._col) + 1;
        return rowDistance * colDistance;
    };
    $p.hasSameRow = function Cell_hasSameRow(other) {
        return this._row == other._row;
    };
    $p.hasSameColumn = function Cell_hasSameColumn(other) {
        return this._col == other._col;
    };
    $p.isWithin$1 = function Cell_isWithin(start, end) {
        if (this._row < start._row)
            return false;
        if (this._col < start._col)
            return false;
        if (this._row > end._row)
            return false;
        if (this._col > end._col)
            return false;
        return true;
    };
    $p.isWithin = function Cell_isWithin(aGrid) {
        return aGrid.hasCell(this._row, this._col);
    };
    $p.rowIndex = function Cell_rowIndex() {
        return this._row;
    };
    $p.columnIndex = function Cell_columnIndex() {
        return this._col;
    };
    $p.isEqual = function Cell_isEqual(other) {
        if (other._row != this._row)
            return false;
        if (other._col != this._col)
            return false;
        return true;
    };
    $p.plusCell = function Cell_plusCell(rowCells, colCells) {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row + rowCells, this._col + colCells);
    };
    $p.minusCell = function Cell_minusCell(rowCells, colCells) {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row - rowCells, this._col - colCells);
    };
    $p.minusSize = function Cell_minusSize(rowSize, colSize) {
        if (rowSize == 0)
            rowSize = 1;
        if (colSize == 0)
            colSize = 1;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row - (rowSize - 1), this._col - (colSize - 1));
    };
    $p.plusSize = function Cell_plusSize(rowSize, colSize) {
        if (rowSize == 0)
            rowSize = 1;
        if (colSize == 0)
            colSize = 1;
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._row + (rowSize - 1), this._col + (colSize - 1));
    };
    $p.cells = function Cell_cells(other) {
        var min = this;
        var max = other;
        if (this.isGreatherThan(other)) {
            min = other;
            max = this;
        }

        var cellsNumber = this.distance(other);
        var result = $d.array(DungeonGeneration.Generator.Domain.Cell, cellsNumber);

        var cellIndex = 0;
        for (var row = min._row; row <= max._row; row++) {
            for (var col = min._col; col <= max._col; col++) {
                result[cellIndex] = new DungeonGeneration.Generator.Domain.Cell.ctor(row, col);
                cellIndex++;
            }
        }
        return result;
    };
    $p.isGreatherThan = function Cell_isGreatherThan(other) {
        var distanceA = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(this);
        var distanceB = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0).distance(other);
        return distanceA > distanceB;
    };
});
DungeonGeneration.Generator.Domain.IShape = $d.type("DungeonGeneration.Generator.Domain.IShape", 66, $asm, function($t, $p) {
});
$d.define(Corridor, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Domain.IShape];
    $t.$ator = function() {
        this._topLeftVertex = null;
        this._topRightVertex = null;
        this._botLeftVertex = null;
        this._botRightVertex = null;
        this._grid = null;
        this._orientation = 0 /* Orientation */;
        this._sourceRoom = null;
        this._destRoom = null;
    };
    $t.Orientation = $d.typeEnum("Orientation", 45, $t, 258, ["horizontal", "vertical"], [0, 1]);
    $t.ctor = function Corridor(topLeftVertex, size, orientation) {
        $t.$baseType.ctor.call(this);
        this._topLeftVertex = topLeftVertex;
        this._topRightVertex = size.absTopRightVertexUsing(this._topLeftVertex);
        this._botLeftVertex = size.absBotLeftVertexUsing(this._topLeftVertex);
        this._botRightVertex = size.absBotRightVertexUsing(this._topLeftVertex);
        this._grid = size;
        this._orientation = orientation;
    };
    $p.isCellPerimetral = function Corridor_isCellPerimetral(pos) {
        if (pos.isWithin$1(this.topLeftVertex(), this.topRightVertex()))
            return true;
        if (pos.isWithin$1(this.topRightVertex(), this.bottomRightVertex()))
            return true;
        if (pos.isWithin$1(this.bottomLeftVertex(), this.bottomRightVertex()))
            return true;
        if (pos.isWithin$1(this.topLeftVertex(), this.bottomLeftVertex()))
            return true;
        return false;
    };
    $p.plotOn = function Corridor_plotOn(map, plotter) {
        if (this.hasDestRoom())
            this.destRoom().plotOn(map, plotter);
        plotter.DungeonGeneration$Generator$Plotters$IPlotter$applyOnCorridor(this, map);
    };
    $p.bottomRightVertex = function Corridor_bottomRightVertex() {
        return this._botRightVertex;
    };
    $p.topRightVertex = function Corridor_topRightVertex() {
        return this._topRightVertex;
    };
    $p.topLeftVertex = function Corridor_topLeftVertex() {
        return this._topLeftVertex;
    };
    $p.setDestinationRoom = function Corridor_setDestinationRoom(room) {
        this._destRoom = room;
    };
    $p.width = function Corridor_width() {
        return this._grid.columns();
    };
    $p.bottomLeftVertex = function Corridor_bottomLeftVertex() {
        return this._botLeftVertex;
    };
    $p.setSourceRoom = function Corridor_setSourceRoom(room) {
        this._sourceRoom = room;
    };
    $p.height = function Corridor_height() {
        return this._grid.rows();
    };
    $p.isVertical = function Corridor_isVertical() {
        return this._orientation == 1 /* Orientation.vertical */;
    };
    $p.isOrizontal = function Corridor_isOrizontal() {
        return this._orientation == 0 /* Orientation.horizontal */;
    };
    $p.isSharingVertex = function Corridor_isSharingVertex(vertex) {
        if (vertex.isEqual(this._topLeftVertex))
            return true;
        if (vertex.isEqual(this._topRightVertex))
            return true;
        if (vertex.isEqual(this._botLeftVertex))
            return true;
        if (vertex.isEqual(this._botRightVertex))
            return true;
        return false;
    };
    $p.isWithin = function Corridor_isWithin(container) {
        return this._grid.isWithin(container, this._topLeftVertex);
    };
    $p.isSharingBottomLeftVertexWithSourceRoom = function Corridor_isSharingBottomLeftVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.bottomLeftVertex());
    };
    $p.isSharingBottomRightVertexWithSourceRoom = function Corridor_isSharingBottomRightVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.bottomRightVertex());
    };
    $p.isSharingTopLeftVertexWithSourceRoom = function Corridor_isSharingTopLeftVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.topLeftVertex());
    };
    $p.isSharingTopRightVertexWithSourceRoom = function Corridor_isSharingTopRightVertexWithSourceRoom() {
        if (!this.hasSourceRoom())
            return false;
        return this.sourceRoom().isSharingVertex(this.topRightVertex());
    };
    $p.isSharingBottomLeftVertexWithDestRoom = function Corridor_isSharingBottomLeftVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.bottomLeftVertex());
    };
    $p.isSharingBottomRightVertexWithDestRoom = function Corridor_isSharingBottomRightVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.bottomRightVertex());
    };
    $p.isSharingTopLeftVertexWithDestRoom = function Corridor_isSharingTopLeftVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.topLeftVertex());
    };
    $p.isSharingTopRightVertexWithDestRoom = function Corridor_isSharingTopRightVertexWithDestRoom() {
        if (!this.hasDestRoom())
            return false;
        return this.destRoom().isSharingVertex(this.topRightVertex());
    };
    $p.hasSourceRoom = function Corridor_hasSourceRoom() {
        return this.sourceRoom() != null;
    };
    $p.hasDestRoom = function Corridor_hasDestRoom() {
        return this.destRoom() != null;
    };
    $p.sourceRoom = function Corridor_sourceRoom() {
        return this._sourceRoom;
    };
    $p.destRoom = function Corridor_destRoom() {
        return this._destRoom;
    };
    $p.collidesWith = function Corridor_collidesWith(each) {
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._topLeftVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._topRightVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._botRightVertex))
            return true;
        if (each.DungeonGeneration$Generator$Domain$IShape$containsCell(this._botLeftVertex))
            return true;
        return false;
    };
    $p.containsCell = function Corridor_containsCell(aCell) {
        return aCell.isWithin$1(this._topLeftVertex, this._botRightVertex);
    };
    $p.ToString = function Corridor_ToString() {
        return "Corridor: " + $d.toString(this.topLeftVertex()) + " " + $d.toString(this._grid);
    };
    $p.walkableCells = function Corridor_walkableCells() {
        var innerA = null;
        var innerB = null;
        if (this.isOrizontal()) {
            innerA = this.topLeftVertex().plusCell(1, 0);
            innerB = this.bottomRightVertex().minusCell(1, 0);
        }
        else {
            innerA = this.topLeftVertex().plusCell(0, 1);
            innerB = this.bottomRightVertex().minusCell(0, 1);
        }
        return innerA.cells(innerB);
    };
    $p.DungeonGeneration$Generator$Domain$IShape$isWithin = $p.isWithin;
    $p.DungeonGeneration$Generator$Domain$IShape$collidesWith = $p.collidesWith;
    $p.DungeonGeneration$Generator$Domain$IShape$containsCell = $p.containsCell;
    $p.DungeonGeneration$Generator$Domain$IShape$plotOn = $p.plotOn;
});
$d.define(DungeonGeneration.Generator.Domain.Grid, null, function($t, $p) {
    $t.$ator = function() {
        this._columns = 0;
        this._rows = 0;
    };
    $t.ctor = function Grid(rows, columns) {
        $t.$baseType.ctor.call(this);
        this._columns = columns;
        this._rows = rows;
    };
    $p.columns = function Grid_columns() {
        return this._columns;
    };
    $p.rows = function Grid_rows() {
        return this._rows;
    };
    $p.isWithin = function Grid_isWithin(container, topLeftVertex) {
        if (!this.absTopLeftVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absTopRightVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absBotRightVertexUsing(topLeftVertex).isWithin(container))
            return false;
        if (!this.absBotLeftVertexUsing(topLeftVertex).isWithin(container))
            return false;
        return true;
    };
    $p.absTopLeftVertexUsing = function Grid_absTopLeftVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(0, 0);
    };
    $p.absBotLeftVertexUsing = function Grid_absBotLeftVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(this._rows - 1, 0);
    };
    $p.absBotRightVertexUsing = function Grid_absBotRightVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(this._rows - 1, this._columns - 1);
    };
    $p.absTopRightVertexUsing = function Grid_absTopRightVertexUsing(topLeftVertex) {
        return topLeftVertex.plusCell(0, this._columns - 1);
    };
    $p.hasCell = function Grid_hasCell(rowIndex, colIndex) {
        if (rowIndex < 0 || rowIndex >= this._rows)
            return false;
        if (colIndex < 0 || colIndex >= this._columns)
            return false;
        return true;
    };
    $p.toIntMatrix = function Grid_toIntMatrix() {
        return $d.array(System.Int32, this._rows * this._columns, [this._rows, this._columns]);
    };
    $p.topLeftVertex = function Grid_topLeftVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0);
    };
    $p.topRightVertex = function Grid_topRightVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(0, this._columns - 1);
    };
    $p.bottomLeftVertex = function Grid_bottomLeftVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._rows - 1, 0);
    };
    $p.bottomRightVertex = function Grid_bottomRightVertex() {
        return new DungeonGeneration.Generator.Domain.Cell.ctor(this._rows - 1, this._columns - 1);
    };
    $p.ToString = function Grid_ToString() {
        return "XGrid: [" + $d.toString(this._rows) + ", " + $d.toString(this._columns) + "]";
    };
});
$d.define(Room, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Domain.IShape];
    $t.$ator = function() {
        this._grid = null;
        this._topLeftVertex = null;
        this._topRightVertex = null;
        this._botLeftVertex = null;
        this._botRightVertex = null;
        this._outcomingCorridor = null;
        this._incomingCorridor = null;
    };
    $t.ctor = function Room(topLeftVertex, size) {
        $t.$baseType.ctor.call(this);
        this._topLeftVertex = topLeftVertex;
        this._topRightVertex = size.absTopRightVertexUsing(this._topLeftVertex);
        this._botLeftVertex = size.absBotLeftVertexUsing(this._topLeftVertex);
        this._botRightVertex = size.absBotRightVertexUsing(this._topLeftVertex);
        this._grid = size;
    };
    $p.setCorridorIncoming = function Room_setCorridorIncoming(corr) {
        this._incomingCorridor = corr;
    };
    $p.setCorridorOutcoming = function Room_setCorridorOutcoming(corr) {
        this._outcomingCorridor = corr;
    };
    $p.topRightVertex = function Room_topRightVertex() {
        return this._topRightVertex;
    };
    $p.bottomLeftVertex = function Room_bottomLeftVertex() {
        return this._botLeftVertex;
    };
    $p.topLeftVertex = function Room_topLeftVertex() {
        return this._topLeftVertex;
    };
    $p.bottomRightVertex = function Room_bottomRightVertex() {
        return this._botRightVertex;
    };
    $p.ToString = function Room_ToString() {
        return "Room: " + $d.toString(this.topLeftVertex()) + " " + $d.toString(this._grid);
    };
    $p.plotOn = function Room_plotOn(map, plotter) {
        plotter.DungeonGeneration$Generator$Plotters$IPlotter$applyOnRoom(this, map);
        if (this._outcomingCorridor != null)
            this._outcomingCorridor.plotOn(map, plotter);
    };
    $p.hasCorridorSharingVertex = function Room_hasCorridorSharingVertex(vertex) {
        var result = false;
        if (this._incomingCorridor != null) {
            result = result || this._incomingCorridor.isSharingVertex(vertex);
        }
        if (this._outcomingCorridor != null) {
            result = result || this._outcomingCorridor.isSharingVertex(vertex);
        }
        return result;
    };
    $p.height = function Room_height() {
        return this._grid.rows();
    };
    $p.width = function Room_width() {
        return this._grid.columns();
    };
    $p.isSharingVertex = function Room_isSharingVertex(vertex) {
        if (vertex.isEqual(this._topLeftVertex))
            return true;
        if (vertex.isEqual(this._topRightVertex))
            return true;
        if (vertex.isEqual(this._botLeftVertex))
            return true;
        if (vertex.isEqual(this._botRightVertex))
            return true;
        return false;
    };
    $p.isWithin = function Room_isWithin(container) {
        return this._grid.isWithin(container, this._topLeftVertex);
    };
    $p.collidesWith = function Room_collidesWith(other) {
        var cells = this._topLeftVertex.cells(this._botRightVertex);
        for (var $i = 0, $length = cells.length; $i < $length; $i++) {
            var each = cells[$i];
            if (other.DungeonGeneration$Generator$Domain$IShape$containsCell(each))
                return true;
        }
        return false;
    };
    $p.containsCell = function Room_containsCell(aCell) {
        return aCell.isWithin$1(this._topLeftVertex, this._botRightVertex);
    };
    $p.walkableCells = function Room_walkableCells() {
        var result = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        var innerTopLeft = this.topLeftVertex().plusCell(1, 1);
        var innerBotRight = this.bottomRightVertex().minusCell(1, 1);
        result.AddRange(innerTopLeft.cells(innerBotRight));
        return result.ToArray();
    };
    $p.hasCorridorAtEast = function Room_hasCorridorAtEast() {
        return this.isEast(this._incomingCorridor) || this.isEast(this._outcomingCorridor);
    };
    $p.hasCorridorAtSouth = function Room_hasCorridorAtSouth() {
        return this.isSouth(this._incomingCorridor) || this.isSouth(this._outcomingCorridor);
    };
    $p.hasCorridorAtWest = function Room_hasCorridorAtWest() {
        return this.isWest(this._incomingCorridor) || this.isWest(this._outcomingCorridor);
    };
    $p.hasCorridorAtNorth = function Room_hasCorridorAtNorth() {
        return this.isNorth(this._incomingCorridor) || this.isNorth(this._outcomingCorridor);
    };
    $p.isNorth = function Room_isNorth(corr) {
        if (corr == null)
            return false;
        return corr.bottomLeftVertex().isWithin$1(this.topLeftVertex(), this.topRightVertex());
    };
    $p.isWest = function Room_isWest(corr) {
        if (corr == null)
            return false;
        return corr.topRightVertex().isWithin$1(this.topLeftVertex(), this.bottomLeftVertex());
    };
    $p.isSouth = function Room_isSouth(corr) {
        if (corr == null)
            return false;
        return corr.topLeftVertex().isWithin$1(this.bottomLeftVertex(), this.bottomRightVertex());
    };
    $p.isEast = function Room_isEast(corr) {
        if (corr == null)
            return false;
        return corr.topLeftVertex().isWithin$1(this.topRightVertex(), this.bottomRightVertex());
    };
    $p.cellsFacingOutcomingCorridor = function Room_cellsFacingOutcomingCorridor() {
        return this.cellFacingCorridor(this._outcomingCorridor);
    };
    $p.cellsFacingIncomingCorridor = function Room_cellsFacingIncomingCorridor() {
        return this.cellFacingCorridor(this._incomingCorridor);
    };
    $p.cellFacingCorridor = function Room_cellFacingCorridor(corr) {
        if (corr == null)
            return $d.array(DungeonGeneration.Generator.Domain.Cell, 0);

        var vertex1 = null;
        var vertex2 = null;
        if (this.isEast(corr)) {
            vertex1 = corr.topLeftVertex().plusCell(1, -1);
            vertex2 = corr.bottomLeftVertex().minusCell(1, 1);
        }
        else if (this.isSouth(corr)) {
            vertex1 = corr.topLeftVertex().plusCell(-1, 1);
            vertex2 = corr.topRightVertex().minusCell(1, 1);
        }
        else if (this.isWest(corr)) {
            vertex1 = corr.topRightVertex().plusCell(1, 1);
            vertex2 = corr.bottomRightVertex().minusCell(1, -1);
        }
        else if (this.isNorth(corr)) {
            vertex1 = corr.bottomLeftVertex().plusCell(1, 1);
            vertex2 = corr.bottomRightVertex().plusCell(1, -1);
        }
        return vertex1.cells(vertex2);
    };
    $p.DungeonGeneration$Generator$Domain$IShape$isWithin = $p.isWithin;
    $p.DungeonGeneration$Generator$Domain$IShape$collidesWith = $p.collidesWith;
    $p.DungeonGeneration$Generator$Domain$IShape$containsCell = $p.containsCell;
    $p.DungeonGeneration$Generator$Domain$IShape$plotOn = $p.plotOn;
});
DungeonGeneration.Generator.Pickers.CardinalPoint = $d.typeEnum("DungeonGeneration.Generator.Pickers.CardinalPoint", 45, $asm, 257, ["NORD", "EST", "SUD", "WEST"], [0, 1, 2, 3]);
$d.define(DungeonGeneration.Generator.Pickers.CardinalPointPicker, null, function($t, $p) {
    $t.$ator = function() {
        this._intRangePicker = null;
    };
    $t.ctor = function CardinalPointPicker(aStrategy) {
        $t.$baseType.ctor.call(this);
        this._intRangePicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(0, 3, aStrategy);
    };
    $p.draw = function CardinalPointPicker_draw() {
        return this._intRangePicker.draw();
    };
    $p.nextClockwise = function CardinalPointPicker_nextClockwise(aPoint) {
        var next = ((aPoint | 0) + 1) % 4;
        return next;
    };
});
$d.define(DungeonGeneration.Generator.Pickers.CellInRangePicker, null, function($t, $p) {
    $t.$ator = function() {
        this._strategy = null;
        this._min = null;
        this._max = null;
    };
    $t.ctor = function CellInRangePicker(aStrategy) {
        $t.$baseType.ctor.call(this);
        this._strategy = aStrategy;
    };
    $p.drawBetween = function CellInRangePicker_drawBetween(min, max) {
        return this.drawBetweenWithExclusion(min, max, $d.array(DungeonGeneration.Generator.Domain.Cell, 
            []));
    };
    $p.drawBetweenWithExclusion = function CellInRangePicker_drawBetweenWithExclusion(min, max, excluded) {
        if (min.hasNegativeIndexes() && max.hasNegativeIndexes())
            return min;
        if (min.hasNegativeIndexes())
            min = min.toNearestPositiveCell();
        if (max.hasNegativeIndexes())
            max = max.toNearestPositiveCell();

        var uniqueExclusion = new (System.Collections.Generic.HashSet$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor)();
        for (var $i = 0, $length = excluded.length; $i < $length; $i++) {
            var each = excluded[$i];
            var toAdd = each;
            if (each.hasNegativeIndexes())
                toAdd = toAdd.toNearestPositiveCell();
            uniqueExclusion.Add(toAdd);
        }

        var cleanedExclusions = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor$1)(uniqueExclusion);
        //cleanedExclusions.Remove(min);
        //cleanedExclusions.Remove(max);

        var distance = min.distance(max) - cleanedExclusions.get_Count();
        if (distance <= 0)
            return min;

        var selectedCellPosition = this._strategy.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween(0, 
            distance - 1);

        var cells = min.cells(max);
        var asList = new (System.Collections.Generic.List$1(DungeonGeneration.Generator.Domain.Cell, 
            14885).ctor$1)(cells);
        var $iter = cleanedExclusions;
        var $enumerator = $iter.System$Collections$IEnumerable$GetEnumerator();
        while ($enumerator.System$Collections$IEnumerator$MoveNext()) {
            var each = $enumerator.System$Collections$IEnumerator$get_Current();
            asList.Remove(each);
        }
        return asList.get_Item(selectedCellPosition);
    };
});
DungeonGeneration.Generator.Pickers.IPickerStrategy = $d.type("DungeonGeneration.Generator.Pickers.IPickerStrategy", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Pickers.IPickerStrategy];
    $t.$ator = function() {
        this._originalSeed = 0;
        this._currentSeed = 0;
        this._logger = null;
    };
    $t.ctor = function CustomSeededPickerStrategy(seed) {
        $t.$baseType.ctor.call(this);
        this._originalSeed = seed;
        this._currentSeed = seed;
        this._logger = new DungeonGeneration.Logging.NullLogger.ctor();
    };
    $p.setLogger = function CustomSeededPickerStrategy_setLogger(logger) {
        this._logger = logger;
    };
    $p.drawBetween = function CustomSeededPickerStrategy_drawBetween(valueA, valueB) {
        this._logger.DungeonGeneration$Logging$IXLogger$info("seed: " + $d.toString(this._currentSeed));
        this._logger.DungeonGeneration$Logging$IXLogger$info("range: " + $d.toString(valueA) + " " + $d.toString(valueB));


        var baseNumber = System.Math.Sin(this._currentSeed) * 10000;
        this._logger.DungeonGeneration$Logging$IXLogger$info("base: " + $d.toString(baseNumber));
        var percentage = baseNumber - System.Math.Floor$1(baseNumber);
        this._logger.DungeonGeneration$Logging$IXLogger$info("percentage: " + $d.toString(percentage));

        var rangeDiff = System.Math.Abs(valueB - valueA) + 1;
        this._logger.DungeonGeneration$Logging$IXLogger$info("rangeDiff: " + $d.toString(rangeDiff));

        var sel = percentage * rangeDiff - 1;
        this._logger.DungeonGeneration$Logging$IXLogger$info("selection: " + $d.toString(sel));

        //Can't use the enum because DuoCode (C# to JS Converter) 
        // fails converting MidpointRounding.AwayFromZero 
        var index = (System.Math.Round$1(sel, 0) | 0);
        this._logger.DungeonGeneration$Logging$IXLogger$info("index before: " + $d.toString(index));
        if (index < 0)
            index = 0;
        this._logger.DungeonGeneration$Logging$IXLogger$info("index after: " + $d.toString(index));

        var result;
        if (valueA <= valueB) {
            result = valueA + index;
        }
        else {
            result = valueA - index;
        }
        this._logger.DungeonGeneration$Logging$IXLogger$info("result: " + $d.toString(result));
        if (this._originalSeed >= 0)
            this._currentSeed++;
        else
            this._currentSeed--;
        return result;
    };
    $p.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween = $p.drawBetween;
});
$d.define(DungeonGeneration.Generator.Pickers.IntInRangePicker, null, function($t, $p) {
    $t.$ator = function() {
        this._max = 0;
        this._min = 0;
        this._pickStrategy = null;
    };
    $t.ctor = function IntInRangePicker(min, max, pickStrategy) {
        $t.$baseType.ctor.call(this);
        this._min = min;
        this._max = max;
        this._pickStrategy = pickStrategy;
    };
    $p.draw = function IntInRangePicker_draw() {
        return this._pickStrategy.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween(this._min, 
            this._max);
    };
});
$d.define(DungeonGeneration.Generator.Pickers.RandomSeededPickerStrategy, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Pickers.IPickerStrategy];
    $t.$ator = function() {
        this._random = null;
        this._seed = 0;
    };
    $t.ctor = function RandomSeededPickerStrategy(seed) {
        $t.$baseType.ctor.call(this);
        this._seed = seed;
        this._random = new System.Random.ctor$1(seed);
    };
    $p.drawBetween = function RandomSeededPickerStrategy_drawBetween(min, max) {
        return this._random.Next$2(min, max);
    };
    $p.DungeonGeneration$Generator$Pickers$IPickerStrategy$drawBetween = $p.drawBetween;
});
DungeonGeneration.Generator.Plotters.IPlotter = $d.type("DungeonGeneration.Generator.Plotters.IPlotter", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Generator.Plotters.DetailedTilesPlotter, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Plotters.IPlotter];
    $t.ctor = function DetailedTilesPlotter() {
        $t.$baseType.ctor.call(this);
    };
    $p.applyOnCorridor = function DetailedTilesPlotter_applyOnCorridor(corridor, map) {
        for (var row = 0; row < corridor.height(); row++) {
            for (var col = 0; col < corridor.width(); col++) {
                var pos = corridor.topLeftVertex().plusCell(row, col);
                var rowPos = pos.rowIndex();
                var colPos = pos.columnIndex();

                if (pos.isEqual(corridor.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 11 /* DetailedTileType.Corner_OUT_NW */ : 13 /* DetailedTileType.Corner_OUT_SE */;
                }
                else if (pos.isEqual(corridor.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 10 /* DetailedTileType.Corner_OUT_NE */ : 12 /* DetailedTileType.Corner_OUT_SW */;
                }
                else if (pos.isEqual(corridor.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 13 /* DetailedTileType.Corner_OUT_SE */ : 11 /* DetailedTileType.Corner_OUT_NW */;
                }
                else if (pos.isEqual(corridor.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = corridor.isVertical() ? 12 /* DetailedTileType.Corner_OUT_SW */ : 10 /* DetailedTileType.Corner_OUT_NE */;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.topRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 2 /* DetailedTileType.Wall_N */;
                }
                else if (pos.isWithin$1(corridor.topRightVertex(), corridor.bottomRightVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 3 /* DetailedTileType.Wall_E */;
                }
                else if (pos.isWithin$1(corridor.bottomLeftVertex(), corridor.bottomRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 4 /* DetailedTileType.Wall_S */;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.bottomLeftVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 5 /* DetailedTileType.Wall_W */;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* DetailedTileType.Floor */;
                }
            }
        }

        // Check if corridor shares vertexes with Source Room and Destination Room
        if (corridor.isSharingBottomLeftVertexWithSourceRoom()) {
            map[corridor.bottomLeftVertex().rowIndex() * map.$ranks[1] + corridor.bottomLeftVertex().columnIndex()] = corridor.isVertical() ? 5 /* DetailedTileType.Wall_W */ : 4 /* DetailedTileType.Wall_S */;
        }
        if (corridor.isSharingTopRightVertexWithSourceRoom()) {
            map[corridor.topRightVertex().rowIndex() * map.$ranks[1] + corridor.topRightVertex().columnIndex()] = corridor.isVertical() ? 3 /* DetailedTileType.Wall_E */ : 2 /* DetailedTileType.Wall_N */;
        }
        if (corridor.isSharingTopLeftVertexWithSourceRoom()) {
            map[corridor.topLeftVertex().rowIndex() * map.$ranks[1] + corridor.topLeftVertex().columnIndex()] = corridor.isVertical() ? 5 /* DetailedTileType.Wall_W */ : 2 /* DetailedTileType.Wall_N */;
        }
        if (corridor.isSharingBottomRightVertexWithSourceRoom()) {
            map[corridor.bottomRightVertex().rowIndex() * map.$ranks[1] + corridor.bottomRightVertex().columnIndex()] = corridor.isVertical() ? 3 /* DetailedTileType.Wall_E */ : 4 /* DetailedTileType.Wall_S */;
        }

        if (corridor.isSharingBottomLeftVertexWithDestRoom()) {
            map[corridor.bottomLeftVertex().rowIndex() * map.$ranks[1] + corridor.bottomLeftVertex().columnIndex()] = corridor.isVertical() ? 5 /* DetailedTileType.Wall_W */ : 4 /* DetailedTileType.Wall_S */;
        }
        if (corridor.isSharingTopRightVertexWithDestRoom()) {
            map[corridor.topRightVertex().rowIndex() * map.$ranks[1] + corridor.topRightVertex().columnIndex()] = corridor.isVertical() ? 3 /* DetailedTileType.Wall_E */ : 2 /* DetailedTileType.Wall_N */;
        }
        if (corridor.isSharingTopLeftVertexWithDestRoom()) {
            map[corridor.topLeftVertex().rowIndex() * map.$ranks[1] + corridor.topLeftVertex().columnIndex()] = corridor.isVertical() ? 5 /* DetailedTileType.Wall_W */ : 2 /* DetailedTileType.Wall_N */;
        }
        if (corridor.isSharingBottomRightVertexWithDestRoom()) {
            map[corridor.bottomRightVertex().rowIndex() * map.$ranks[1] + corridor.bottomRightVertex().columnIndex()] = corridor.isVertical() ? 3 /* DetailedTileType.Wall_E */ : 4 /* DetailedTileType.Wall_S */;
        }
    };
    $p.applyOnRoom = function DetailedTilesPlotter_applyOnRoom(room, map) {
        for (var row = 0; row < room.height(); row++) {
            for (var col = 0; col < room.width(); col++) {
                var pos = room.topLeftVertex().plusCell(row, col);
                var rowPos = pos.rowIndex();
                var colPos = pos.columnIndex();

                if (pos.isEqual(room.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* DetailedTileType.Empty */;
                }
                else if (pos.isEqual(room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* DetailedTileType.Empty */;
                }
                else if (pos.isEqual(room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* DetailedTileType.Empty */;
                }
                else if (pos.isEqual(room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* DetailedTileType.Empty */;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 2 /* DetailedTileType.Wall_N */;
                }
                else if (pos.isWithin$1(room.topRightVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 3 /* DetailedTileType.Wall_E */;
                }
                else if (pos.isWithin$1(room.bottomLeftVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 4 /* DetailedTileType.Wall_S */;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 5 /* DetailedTileType.Wall_W */;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* DetailedTileType.Floor */;
                }
            }
        }

        this.joinWithCorridors(room, map);
    };
    $p.joinWithCorridors = function DetailedTilesPlotter_joinWithCorridors(room, map) {
        var xPosC;
        var yPosC;

        //TOP LEFT VERTEX
        if (!room.hasCorridorSharingVertex(room.topLeftVertex())) {
            xPosC = room.topLeftVertex().rowIndex();
            yPosC = room.topLeftVertex().columnIndex();
            map[xPosC * map.$ranks[1] + yPosC] = 6 /* DetailedTileType.Corner_INN_NW */;
            map[xPosC * map.$ranks[1] + (yPosC + 1)] = 0 /* DetailedTileType.Empty */;
            map[(xPosC + 1) * map.$ranks[1] + yPosC] = 0 /* DetailedTileType.Empty */;
        }

        //TOP RIGHT VERTEX
        if (!room.hasCorridorSharingVertex(room.topRightVertex())) {
            xPosC = room.topRightVertex().rowIndex();
            yPosC = room.topRightVertex().columnIndex();
            map[xPosC * map.$ranks[1] + yPosC] = 7 /* DetailedTileType.Corner_INN_NE */;
            map[xPosC * map.$ranks[1] + (yPosC - 1)] = 0 /* DetailedTileType.Empty */;
            map[(xPosC + 1) * map.$ranks[1] + yPosC] = 0 /* DetailedTileType.Empty */;
        }

        //BOTTOM RIGHT VERTEX
        if (!room.hasCorridorSharingVertex(room.bottomRightVertex())) {
            xPosC = room.bottomRightVertex().rowIndex();
            yPosC = room.bottomRightVertex().columnIndex();
            map[xPosC * map.$ranks[1] + yPosC] = 8 /* DetailedTileType.Corner_INN_SE */;
            map[xPosC * map.$ranks[1] + (yPosC - 1)] = 0 /* DetailedTileType.Empty */;
            map[(xPosC - 1) * map.$ranks[1] + yPosC] = 0 /* DetailedTileType.Empty */;
        }

        if (!room.hasCorridorSharingVertex(room.bottomLeftVertex())) {
            xPosC = room.bottomLeftVertex().rowIndex();
            yPosC = room.bottomLeftVertex().columnIndex();
            map[xPosC * map.$ranks[1] + yPosC] = 9 /* DetailedTileType.Corner_INN_SW */;
            map[xPosC * map.$ranks[1] + (yPosC + 1)] = 0 /* DetailedTileType.Empty */;
            map[(xPosC - 1) * map.$ranks[1] + yPosC] = 0 /* DetailedTileType.Empty */;
        }
    };
    $p.DungeonGeneration$Generator$Plotters$IPlotter$applyOnRoom = $p.applyOnRoom;
    $p.DungeonGeneration$Generator$Plotters$IPlotter$applyOnCorridor = $p.applyOnCorridor;
});
DungeonGeneration.Generator.Plotters.DetailedTileType = $d.typeEnum("DungeonGeneration.Generator.Plotters.DetailedTileType", 45, $asm, 257, ["Empty", "Floor", "Wall_N", "Wall_E", "Wall_S", "Wall_W", "Corner_INN_NW", "Corner_INN_NE", "Corner_INN_SE", "Corner_INN_SW", "Corner_OUT_NE", "Corner_OUT_NW", "Corner_OUT_SW", "Corner_OUT_SE"], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
$d.define(DungeonGeneration.Generator.Plotters.ZeroOneTilesPlotter, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Generator.Plotters.IPlotter];
    $t.ctor = function ZeroOneTilesPlotter() {
        $t.$baseType.ctor.call(this);
    };
    $p.applyOnCorridor = function ZeroOneTilesPlotter_applyOnCorridor(corridor, map) {
        for (var row = 0; row < corridor.height(); row++) {
            for (var col = 0; col < corridor.width(); col++) {
                var pos = corridor.topLeftVertex().plusCell(row, col);
                var rowPos = pos.rowIndex();
                var colPos = pos.columnIndex();

                if (pos.isEqual(corridor.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(corridor.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(corridor.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(corridor.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.topRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(corridor.topRightVertex(), corridor.bottomRightVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(corridor.bottomLeftVertex(), corridor.bottomRightVertex()) && corridor.isOrizontal()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(corridor.topLeftVertex(), corridor.bottomLeftVertex()) && corridor.isVertical()) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* ZeroOneTileType.Empty */;
                }
            }
        }
    };
    $p.applyOnRoom = function ZeroOneTilesPlotter_applyOnRoom(room, map) {
        for (var row = 0; row < room.height(); row++) {
            for (var col = 0; col < room.width(); col++) {
                var pos = room.topLeftVertex().plusCell(row, col);
                var rowPos = pos.rowIndex();
                var colPos = pos.columnIndex();

                if (pos.isEqual(room.topLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isEqual(room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.topRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(room.topRightVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(room.bottomLeftVertex(), room.bottomRightVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else if (pos.isWithin$1(room.topLeftVertex(), room.bottomLeftVertex())) {
                    map[rowPos * map.$ranks[1] + colPos] = 1 /* ZeroOneTileType.Wall */;
                }
                else {
                    map[rowPos * map.$ranks[1] + colPos] = 0 /* ZeroOneTileType.Empty */;
                }
            }
        }
    };
    $p.DungeonGeneration$Generator$Plotters$IPlotter$applyOnRoom = $p.applyOnRoom;
    $p.DungeonGeneration$Generator$Plotters$IPlotter$applyOnCorridor = $p.applyOnCorridor;
});
DungeonGeneration.Generator.Plotters.ZeroOneTileType = $d.typeEnum("DungeonGeneration.Generator.Plotters.ZeroOneTileType", 45, $asm, 257, ["Empty", "Wall"], [0, 1]);
$d.define(DungeonGeneration.Generator.TilesMapGenerator, null, function($t, $p) {
    $t.$ator = function() {
        this._corridorSizeMin = 0;
        this._corridorSizeMax = 0;
        this._roomSizeMin = 0;
        this._roomSizeMax = 0;
        this._roomsNumberMin = 0;
        this._roomsNumberMax = 0;
        this._seed = 0;
        this._mapRows = 0;
        this._mapColumns = 0;
        this._logger = null;
        this._plotter = null;
        this._board = null;
    };
    $t.ctor = function TilesMapGenerator() {
        $t.$baseType.ctor.call(this);
        this._logger = new DungeonGeneration.Logging.NullLogger.ctor();
        this.clearBoard();
    };
    $p.clearBoard = function TilesMapGenerator_clearBoard() {
        this._board = null;
    };
    $p.isBoardCleared = function TilesMapGenerator_isBoardCleared() {
        return this._board == null;
    };
    $p.setCorridorSizeRange = function TilesMapGenerator_setCorridorSizeRange(v1, v2) {
        this._corridorSizeMin = v1;
        this._corridorSizeMax = v2;
        this.clearBoard();
    };
    $p.setRoomSizeRange = function TilesMapGenerator_setRoomSizeRange(v1, v2) {
        this._roomSizeMin = v1;
        this._roomSizeMax = v2;
        this.clearBoard();
    };
    $p.setRoomsNumberRange = function TilesMapGenerator_setRoomsNumberRange(v1, v2) {
        this._roomsNumberMin = v1;
        this._roomsNumberMax = v2;
        this.clearBoard();
    };
    $p.setSeed = function TilesMapGenerator_setSeed(v) {
        this._seed = v;
        this.clearBoard();
    };
    $p.setMapSize = function TilesMapGenerator_setMapSize(rows, columns) {
        this._mapRows = rows;
        this._mapColumns = columns;
        this.clearBoard();
    };
    $p.setLogger = function TilesMapGenerator_setLogger(logger) {
        this._logger = logger;
        this.clearBoard();
    };
    $p.asBoard = function TilesMapGenerator_asBoard() {
        if (!this.isBoardCleared())
            return this._board;
        this._board = new DungeonGeneration.Generator.Domain.Board.ctor$1(this._mapRows, this._mapColumns);

        //IPickerStrategy seedStrategy = new RandomSeededPickerStrategy(_seed);
        var seedStrategy = new DungeonGeneration.Generator.Pickers.CustomSeededPickerStrategy.ctor(this._seed);
        seedStrategy.setLogger(this._logger);

        var roomNumberPicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._roomsNumberMin, 
            this._roomsNumberMax, seedStrategy);
        var roomSizePicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._roomSizeMin, 
            this._roomSizeMax, seedStrategy);
        var corrSizePicker = new DungeonGeneration.Generator.Pickers.IntInRangePicker.ctor(this._corridorSizeMin, 
            this._corridorSizeMax, seedStrategy);
        var cardPointPicker = new DungeonGeneration.Generator.Pickers.CardinalPointPicker.ctor(seedStrategy);
        var cellRangePicker = new DungeonGeneration.Generator.Pickers.CellInRangePicker.ctor(seedStrategy);

        var roomNumber = roomNumberPicker.draw();
        if (roomNumber < 1) {
            this._logger.DungeonGeneration$Logging$IXLogger$warning("Room number should be at least 1. Instead is: " + $d.toString(roomNumber));
            return this._board;
        }

        var grid = new DungeonGeneration.Generator.Domain.Grid.ctor(roomSizePicker.draw(), roomSizePicker.draw());
        var topLeftVertexMin = new DungeonGeneration.Generator.Domain.Cell.ctor(0, 0);
        var topLeftVertexMax = new DungeonGeneration.Generator.Domain.Cell.ctor(this._mapRows - 1, this._mapColumns - 1).minusSize(grid.rows(), 
            grid.columns());
        var topLeftCell = cellRangePicker.drawBetween(topLeftVertexMin, topLeftVertexMax);
        var lastRoom = new Room.ctor(topLeftCell, grid);
        if (!this._board.fitsIn(lastRoom)) {
            this._logger.DungeonGeneration$Logging$IXLogger$error("First room not fit in. This should never happen");
            return this._board;
        }
        this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(lastRoom));
        this._board.addRoom(lastRoom);

        var lastDirection = 0;
        var roomCreationAttempt = 1;
        for (var i = 1; i < roomNumber; i++) {
            //If room and corridor has not been dropped, pick random direction
            if (roomCreationAttempt == 1) {
                lastDirection = cardPointPicker.draw();
            }
            else {
                lastDirection = cardPointPicker.nextClockwise(lastDirection); //else force to next direction
            }

            //Try to create a Corridor on a direction if there is enough space
            var cardinalPointAttempt = 1;
            var lastCorridor = null;
            do {
                lastCorridor = this.generateCorridor(lastDirection, lastRoom, corrSizePicker, cellRangePicker);
                if (!this._board.fitsIn(lastCorridor)) {
                    this._logger.DungeonGeneration$Logging$IXLogger$info("NO FITS: " + $d.toString(lastCorridor) + " " + $d.toString($d.boxEnum(DungeonGeneration.Generator.Pickers.CardinalPoint, 
                        lastDirection)));
                    lastCorridor = null;
                    cardinalPointAttempt++;
                    lastDirection = cardPointPicker.nextClockwise(lastDirection);
                }
            }
            while (cardinalPointAttempt <= 4 && lastCorridor == null);

            //If no corridor has been created, then terminate the algorithm
            if (lastCorridor == null) {
                this._logger.DungeonGeneration$Logging$IXLogger$warning("PROCEDURAL GENERATION INTERRUPTED: No more chance for a Corridor to fit in");
                break;
            }
            this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(lastCorridor) + " " + $d.toString($d.boxEnum(DungeonGeneration.Generator.Pickers.CardinalPoint, 
                lastDirection)));
            this._board.addCorridor(lastCorridor);

            //Try to create a room. If there is enough space retry (until 4 times) restarting from a new corridor
            var newRoom = this.generateRoom(lastDirection, lastCorridor, roomSizePicker, cellRangePicker);
            if (!this._board.fitsIn(newRoom)) {
                this._board.removeLast(); //remove last item added to the board (a corridor in this case)
                if (roomCreationAttempt <= 4) {
                    this._logger.DungeonGeneration$Logging$IXLogger$info("NO FITS: " + $d.toString(newRoom) + " Retry: " + $d.toString(roomCreationAttempt));
                    roomCreationAttempt++;
                    i--;
                    continue;
                }
                else {
                    this._logger.DungeonGeneration$Logging$IXLogger$warning("PROCEDURAL GENERATION INTERRUPTED: No more chance for a Room to fit in");
                    break;
                }
            }
            else {
                this._logger.DungeonGeneration$Logging$IXLogger$info("OK: " + $d.toString(newRoom) + " Retry: " + $d.toString(roomCreationAttempt));
                lastRoom = newRoom;
                roomCreationAttempt = 1;
                this._board.addRoom(lastRoom);
            }
        }
        return this._board;
    };
    $p.asMatrix = function TilesMapGenerator_asMatrix() {
        return this.asBoard().asTilesMatrix(this._plotter);
    };
    $p.setPlotter = function TilesMapGenerator_setPlotter(plotter) {
        this._plotter = plotter;
    };
    $p.generateRoom = function TilesMapGenerator_generateRoom(lastCorridorDirection, lastCorr, roomSizePicker, cellInRangePicker) {
        var roomRows = roomSizePicker.draw();
        var roomCols = roomSizePicker.draw();
        var grid = new DungeonGeneration.Generator.Domain.Grid.ctor(roomRows, roomCols);
        var topLeftCell = null;
        if (lastCorridorDirection == 0 /* CardinalPoint.NORD */) {
            var topLeftVertexMax = lastCorr.topLeftVertex().minusSize(roomRows, 0);
            var topLeftVertexMin = topLeftVertexMax.minusCell(0, roomCols - lastCorr.width());
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 1 /* CardinalPoint.EST */) {
            var topLeftVertexMax = lastCorr.topRightVertex();
            var topLeftVertexMin = topLeftVertexMax.minusCell(roomRows - lastCorr.height(), 0);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 2 /* CardinalPoint.SUD */) {
            var topLeftVertexMax = lastCorr.bottomLeftVertex();
            var topLeftVertexMin = topLeftVertexMax.minusCell(0, roomCols - lastCorr.width());
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (lastCorridorDirection == 3 /* CardinalPoint.WEST */) {
            var topLeftVertexMax = lastCorr.topLeftVertex().minusSize(0, roomCols);
            var topLeftVertexMin = topLeftVertexMax.minusCell(roomRows - lastCorr.height(), 0);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellInRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        return new Room.ctor(topLeftCell, grid);
    };
    $p.generateCorridor = function TilesMapGenerator_generateCorridor(mapDirection, lastRoom, corrSizePicker, cellRangePicker) {
        var corridorLenght = corrSizePicker.draw();
        var corridorSection = 3;

        var corrOrient = 0;
        var grid = null;
        var topLeftCell = lastRoom.topLeftVertex();
        if (mapDirection == 0 /* CardinalPoint.NORD */) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorLenght, corridorSection);
            corrOrient = 1 /* Orientation.vertical */;
            var topLeftVertexMin = lastRoom.topLeftVertex().minusSize(corridorLenght, 0);
            var topLeftVertexMax = topLeftVertexMin.plusCell(0, lastRoom.width() - corridorSection);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 1 /* CardinalPoint.EST */) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorSection, corridorLenght);
            corrOrient = 0 /* Orientation.horizontal */;
            var topLeftVertexMin = lastRoom.topRightVertex();
            var topLeftVertexMax = topLeftVertexMin.plusCell(lastRoom.height() - corridorSection, 0);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 2 /* CardinalPoint.SUD */) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorLenght, corridorSection);
            corrOrient = 1 /* Orientation.vertical */;
            var topLeftVertexMin = lastRoom.bottomLeftVertex();
            var topLeftVertexMax = topLeftVertexMin.plusCell(0, lastRoom.width() - corridorSection);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(0, 1);
            var excludeTwo = topLeftVertexMax.minusCell(0, 1);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        else if (mapDirection == 3 /* CardinalPoint.WEST */) {
            grid = new DungeonGeneration.Generator.Domain.Grid.ctor(corridorSection, corridorLenght);
            corrOrient = 0 /* Orientation.horizontal */;
            var topLeftVertexMin = lastRoom.topLeftVertex().minusSize(0, corridorLenght);
            var topLeftVertexMax = topLeftVertexMin.plusCell(lastRoom.height() - corridorSection, 0);
            //Excluding cells to avoid Inward and Outward Corner Walls Overlapping
            var excludeOne = topLeftVertexMin.plusCell(1, 0);
            var excludeTwo = topLeftVertexMax.minusCell(1, 0);
            topLeftCell = cellRangePicker.drawBetweenWithExclusion(topLeftVertexMin, topLeftVertexMax, 
                $d.array(DungeonGeneration.Generator.Domain.Cell, [excludeOne, excludeTwo]));
            this._logger.DungeonGeneration$Logging$IXLogger$info("Min: " + $d.toString(topLeftVertexMin) + " Max: " + $d.toString(topLeftVertexMax) + " Selected: " + $d.toString(topLeftCell) + " Exclusions: " + $d.toString(excludeOne) + " - " + $d.toString(excludeTwo));
        }
        return new Corridor.ctor(topLeftCell, grid, corrOrient);
    };
});
DungeonGeneration.Logging.IXLogger = $d.type("DungeonGeneration.Logging.IXLogger", 66, $asm, function($t, $p) {
});
$d.define(DungeonGeneration.Logging.ConsoleLogger, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Logging.IXLogger];
    $t.ctor = function ConsoleLogger() {
        $t.$baseType.ctor.call(this);
    };
    $p.error = function ConsoleLogger_error(v) {
        System.Console.WriteLine$10("[ERRO]: " + v);
    };
    $p.info = function ConsoleLogger_info(v) {
        System.Console.WriteLine$10("[INFO]: " + v);
    };
    $p.warning = function ConsoleLogger_warning(v) {
        System.Console.WriteLine$10("[WARN]: " + v);
    };
    $p.DungeonGeneration$Logging$IXLogger$warning = $p.warning;
    $p.DungeonGeneration$Logging$IXLogger$error = $p.error;
    $p.DungeonGeneration$Logging$IXLogger$info = $p.info;
});
$d.define(DungeonGeneration.Logging.NullLogger, null, function($t, $p) {
    $t.$intfs = [DungeonGeneration.Logging.IXLogger];
    $t.ctor = function NullLogger() {
        $t.$baseType.ctor.call(this);
    };
    $p.error = function NullLogger_error(v) {
    };
    $p.info = function NullLogger_info(v) {
    };
    $p.warning = function NullLogger_warning(v) {
    };
    $p.DungeonGeneration$Logging$IXLogger$warning = $p.warning;
    $p.DungeonGeneration$Logging$IXLogger$error = $p.error;
    $p.DungeonGeneration$Logging$IXLogger$info = $p.info;
});
return $asm;
})();
